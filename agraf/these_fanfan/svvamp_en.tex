% !TeX spellcheck = en_US
\mychapter{\variantsvvamp{}: \emph{Simulator of Various Voting Algorithms in Manipulating Populations}}\label{sec:svvamp}\chaptermark{\svvamp{}}

%Nous développons \svvamp{}, un package Python dédié à l'étude des modes de scrutin et de leur manipulabilité. Les préférences des électeurs peuvent être importées depuis un fichier extérieur ou générées par divers modèles probabilistes. \svvamp{} implémente plus de 20 modes de scrutin, et sa structure orientée objet facilite l'implémentation de nouveaux systèmes de votes. Une attention particulière est portée sur la \emph{manipulation par coalition} et ses variantes. Des algorithmes pour l'\emph{efficacité Condorcet}, la \emph{manipulation individuelle} et l'\emph{indépendance des alternatives non pertinentes} sont également implémentés.
%
%Décider la manipulation individuelle ou par coalition pour le mode de scrutin \emph{Instant-Runoff Voting} est \complexNP-complet. Nous exhibons une heuristique en temps polynomial qui est capable de trouver une manipulation avec un grand taux de succès quand la situation est manipulable.


%We present \svvamp, a Python package dedicated to the study of voting systems with an emphasis on manipulation analysis. Voters' preferences can be imported from external files or generated by a variety of probabilistic models. \svvamp currently implements more than 20 voting systems, and its object-oriented design facilitates the implementation of new voting systems. Special attention has been paid to Coalitional Manipulability (MC) and its variants. Algorithms for Condorcet efficiency, Individual Manipulability (MI) and Independence of Irrelevant Alternatives (IIA) are also implemented.

Comme nous l'avons déjà évoqué, l'histoire de la théorie du vote a été marquée par la découverte de plusieurs paradoxes, notamment le paradoxe de \cite{condorcet1785essai} ou <<\,paradoxe du vote\,>> sur les comparaisons entre paires de candidats; le paradoxe d'\cite{arrow1950difficulty}, dont un point clé est l'indépendance des alternatives non pertinentes (IANP); et le théorème d'impossibilité de \cite{gibbard1973manipulation} et \cite{satterthwaite1975strategyproofness} sur la manipulabilité.

Puisqu'aucun système de vote non trivial ne peut éviter ces paradoxes totalement, la probabilité d'apparition de ces cas pathologiques dans divers types de cultures a fait l'objet d'intenses investigations \citep{campbell1965cyclical, chamberlin1984observed, nitzan1985vulnerability, lepelley1987proportion, kelly1993almost, aleskerov1999degree, smith1999measures, lepelley2003homogeneity, favardin2006further, pritchard2007exact, aleskerov2008computing, reyhani2009anewmeasure, jennings2011monotonicity, reyhani2013strategic, green2014strategic, wang2014condorcet}.
Cependant, il reste d'importantes questions ouvertes dans le domaine, en particulier à propos des performances relatives des différents systèmes de vote selon divers critères et sous divers jeux d'hypothèses sur les préférences des électeurs.

\medskip
Recently, thanks to the development of the community of computational social choice, interesting results were published about algorithmic issues linked to voting systems and their manipulation. One one hand, about complexity problems, following the line initiated by \cite{bartholdi1989voting} then \cite{bartholdi1991stv}, and it was proven that deciding manipulability was \complexNP-hard for some voting systems. On the other hand, some authors, like~\cite{xia2009unweighted, walsh2009stv, zuckerman2009algorithms, zuckerman2011maximin, gaspers2013schulze}, have designed explicit algorithms to deal with manipulability questions.

This observation led us to develop \svvamp (\textit{Simulator of Various Voting Algorithms in Manipulating Populations}), a Python package designed to study voting systems and their manipulability. It is easy to use, supports a large choice of models for the preferences of the voters (or importation of real-life data) and a variety of voting systems. It is simple to extend \svvamp by adding new models of populations and new voting systems.

\svvamp is a free software, under GNU General Public License version 3.
%
%It is written in Python~3 and uses the packages NumPy, SciPy, matplotlib, NetworkX and pandas. Available from the Python Package Index (PyPI), \svvamp can be installed with \mylstinline$pip$ in the command line:
%
%\begin{lstlisting}
%pip install svvamp
%\end{lstlisting}
%
Its documentation includes installation procedure, tutorials, reference guide and instructions for new contributors. It is available at:
%Its documentation is available on ReadTheDocs:
\begin{center}
\url{https://svvamp.readthedocs.org}.
\end{center}

%Its source code can be found on GitHub: 
%\begin{center}
%\url{https://github.com/francois-durand/svvamp}.
%\end{center}

%\subsection{Plan}

\medskip
After providing a basic example to give a brief overview \svvamp's usage, we present the tools for the Population class, representing a set of voters with preferences over a set of candidates (section~\ref{sec:population}). Then we present the tools for the Election class, which is an abstract class whose all voting systems inherit (section~\ref{sec:elections}). We illustrate the implementation choices made in \svvamp by focusing on the example of Coalitional Manipulability, whose study is one of the main purpose of the software (section~\ref{sec:election_implem}). 
We indicate specific algorithms used for some voting systems (section~\ref{sec:voting_systems_implem}). 
Lastly, we focus on the implementation of IRV and its variants (section~\ref{sec:vti_implem}): indeed, we will see in the following chapters that this voting system is especially resistant to manipulation, hence our more detailed study of this system.


%implementation: general considerations for the class Election (section \ref{sec:election_implem}), manipulations methods implemented in this abstract class (section~\ref{sec:election_methods_implem}) and manipulations methods implemented for specific voting systems (section~\ref{sec:voting_systems_implem}).

\medskip
Let us give a brief overview of \svvamp's usage through a basic example.

%We will note $V$ the number of voters and $C$ the number of candidates. 
After loading \svvamp, we define a random population of $V = 5$ voters with preferences over $C = 4$ candidates by using the \emph{Spheroid} model, which is an extension of the usual \emph{impartial culture} (definition~\ref{def:culture_impartiale}), which we will present with more details in  section~\ref{sec:create_pop}.
%providing their preference rankings manually.

\begin{lstlisting}
>>> import svvamp
>>> pop = svvamp.PopulationSpheroid(V=5, C=4)
\end{lstlisting}
%>>> pop = svvamp.Population(preferences_rk=
%                            [[0, 2, 1, 3],
%                             [3, 2, 0, 1],
%                             [2, 0, 1, 3],
%                             [1, 3, 2, 0],
%                             [1, 3, 2, 0]])

Ceci crée un objet \mylstinline$pop$ de classe Population. Ensuite, nous pouvons trier les électeurs par ordre lexicographique sur leurs ordres de préférence et afficher ces ordres.

\begin{lstlisting}
>>> pop.ensure_voters_sorted_by_rk()
>>> print(pop.preferences_rk)
[[0 2 1 3]
 [1 3 2 0]
 [1 3 2 0]
 [2 0 1 3]
 [3 2 0 1]]
\end{lstlisting}

%The first time \mylstinline$ensure_voters_sorted_by_rk$ is called, it modifies the population in place. If it is called a second time, \svvamp remembers that the population is already sorted and does not perform the computation again.

Chaque ligne de la matrice attribut \mylstinline$preferences_rk$ représente l'ordre strict total de préférence d'un électeur. Par exemple, le premier électeur préfère le candidat~0, puis 2, puis 1, puis 3. Suivant les conventions habituelles en Python, la numérotation des candidats et des électeurs démarre à $0$.

Créons une élection avec cette population d'électeurs, en utilisant le système de vote~\emph{Plurality} (uninominal), et déterminons le vainqueur sincère. Celui-ci, noté~$\winner$ dans \svvamp{} et dans l'ensemble de ce chapitre, est le candidat~1 dans notre exemple.

\begin{lstlisting}
>>> election = svvamp.Plurality(pop)
>>> print(election.w)
1
\end{lstlisting}

\svvamp peut nous dire que l'élection est MC et nous donner des détails sur ce type de manipulation.

%\begin{lstlisting}
%>>> is_CM, log_CM = election.CM()
%>>> print(is_CM)
%True
%\end{lstlisting}
%
%In this example, \svvamp has decided that the election is CM. We can ask for more details.

\begin{lstlisting}
>>> is_CM, log_CM, candidates_CM = election.CM_with_candidates()
>>> print(is_CM)
True
>>> print(candidates_CM)
[ 1.  0.  1.  0.]
\end{lstlisting}

Les candidats 0 ou 2 peuvent bénéficier d'une MC, mais pas le candidat~3. Le candidat~1, c'est-à-dire~$\winner$, est exclu par convention de la définition de MC.

\vspace{0.3cm}%MAGOUILLE

\section{Population}\label{sec:population}

\vspace{0.3cm}%MAGOUILLE

%An object of class Population represents a finite set of voters, with preferences over a finite set of candidates.
Dans cette section, nous présentons comment étudier les propriétés d'une population en poursuivant notre premier exemple (section~\ref{sec:info_pop}). Ensuite, nous montrons que \svvamp n'est pas limité aux ordres stricts totaux de préférence mais peut également exploiter des utilités et des ordres faibles de préférence (section~\ref{sec:vtb}). Enfin, nous présentons un panel d'outils pour définir des populations (section~\ref{sec:create_pop}).

\subsection{Get Information About a Population}\label{sec:info_pop}

Un objet de classe Population possède plusieurs fonctions et attributs qui permettent d'étudier ses propriétés.

%In this paper, we will note $V$ the number of voters and $C$ the number of candidates, like the corresponding attributes in \svvamp.
%
%\begin{lstlisting}
%>>> print(pop.V)
%5
%>>> print(pop.C)
%4
%\end{lstlisting}

%Before going further, let us sort voters by their preference rankings, lexicographically.
%
%\begin{lstlisting}
%>>> pop.ensure_voters_sorted_by_rk()
%\end{lstlisting}
%
%To check the result, we can print the attribute \mylstinline$preferences_rk$ of the population.
%
%\begin{lstlisting}
%>>> print(pop.preferences_rk)
%[[0 2 1 3]
% [1 3 2 0]
% [1 3 2 0]
% [2 0 1 3]
% [3 2 0 1]]
%\end{lstlisting}

Les scores de Borda attribués par les électeurs aux candidats sont directement implantés en tant qu'attribut dans la classe Population, parce qu'ils sont utilisés par plusieurs systèmes de vote.
%rather than in the voting system \emph{Borda}, because they are used for several other voting systems, for example \emph{Baldwin} and \emph{Nanson}.

\begin{lstlisting}
>>> print(pop.preferences_borda_rk)
[[3 1 2 0]
 [0 3 1 2]
 [0 3 1 2]
 [2 1 3 0]
 [1 0 2 3]]
\end{lstlisting}

%The suffix \mylstinline$_rk$ in the same of this attribute will be explained in section~\ref{sec:vtb}.

Le score de Borda total et le score par \emph{Plurality}\footnote{À titre de rappel, le \emph{score par Plurality} (uninominal) d'un candidat~$c$ est le nombre d'électeurs qui placent $c$ en premier dans leur ordre de préférence.} de chaque candidat sont disponibles de la même façon, en utilisant les attributs \mylstinline$borda_score_c_rk$ et \mylstinline$plurality_scores_rk$ respectivement.

%\begin{lstlisting}
%>>> print(pop.borda_score_c_rk)
%[6 8 9 7]
%>>> print(pop.plurality_scores_rk)
%[1 2 1 1]
%\end{lstlisting}

D'autres attributs fournissent la \emph{matrice des duels}, la \emph{matrice des victoires}\footnote{Pour toute paire de candidat distincts $(c, d)$, \mylstinline$matrix_victories_rk[c, d]$ vaut:
\begin{itemize}
\item 1 ssi \mylstinline$matrix_duels_rk[c, d]$ $> V/2$,
\item 0,5 ssi \mylstinline$matrix_duels_rk[c, d]$ $= V/2$,
\item 0 ssi \mylstinline$matrix_duels_rk[c, d]$ $< V/2$.
\end{itemize}
Par convention, les coefficients diagonaux valent 0.} et l'identité du vainqueur de Condorcet.

\begin{lstlisting}
>>> print(pop.matrix_duels_rk)
[[0 3 1 2]
 [2 0 2 4]
 [4 3 0 2]
 [3 1 3 0]]
>>> print(pop.matrix_victories_rk)
[[ 0.  1.  0.  0.]
 [ 0.  0.  0.  1.]
 [ 1.  1.  0.  0.]
 [ 1.  0.  1.  0.]]
>>> print(pop.condorcet_winner_rk)
nan
\end{lstlisting}

Dans cet exemple, la dernière valeur renvoyée est \mylstinline$nan$ (\emph{not a number}), ce qui est une convention signifiant qu'il n'y a pas de vainqueur de Condorcet.

La matrice des duels, la matrice des victoires et le vainqueur de Condorcet ont plusieurs variantes implantées dans \svvamp, qui dépendent de choix de départage des égalités. En particulier, les notions de candidat Condorcet-admissible, vainqueur de Condorcet faible et vainqueur de Condorcet relatif sont implantées. Le lecteur intéressé se reportera à la documentation de \svvamp pour davantage de détails.


\subsection{Work with Utilities}\label{sec:vtb}

La plupart des études sur la vraisemblance d'une manipulation, citées dans l'introduction de ce chapitre, ne concernent que des systèmes de vote ordinaux. Cependant, d'intéressants systèmes de vote sont cardinaux. Un cas particulier en est le vote par assentiment, qui est un important sujet de recherche~(\cite{brams1978approval, fishburn1981efficacy,
brams1994procedures, %brams2003sovereignty, 
brams2003approval, laslier2008live,
laslier2009leader}). Il est aussi utilisé dans des élections de la vie réelle: par exemple, il a été choisi par les théoriciens du choix social pour leurs véritables élections au sein de la \emph{Society of Social Choice and Welfare}.

%This situation is a bit paradoxical: for example, Approval voting, which is a cardinal voting system, is an important object of research~(\cite{brams1978approval, fishburn1981efficacy,
%%brams1994procedures, brams2003sovereignty, brams2003approval, 
%laslier2009leader} and many others) and is considered reasonable enough to be used by social choice theorists themselves for actual elections in the Society of Social Choice and Welfare. 
%
%Some voting systems are \emph{ordinal}: they are generally based on strict orders of preference, sometimes allowing weak orders as well. Other are \emph{cardinal}, which means that a voter's preference ranking does to allow to determine her sincere ballot canonically. For example, these voting systems may require that voters attribute grades to the candidates.
%
%The situation is a bit paradoxical. On one hand, \emph{Approval voting}, which is a cardinal voting system, is an important object of research~(\cite{brams1978approval, fishburn1981efficacy,
%%brams1994procedures, brams2003sovereignty, brams2003approval, 
%laslier2009leader} and many others) and is considered reasonable enough to be used by social choice theorists themselves for actual elections in the Society of Social Choice and Welfare. On the other hand, most of the studies on the likeliness of manipulation, cited in the introduction, deal only with ordinal voting systems (a noticeable exception is~\cite{green2014strategic}).

Un des objectifs de \svvamp est de permettre la comparaison de systèmes de vote ordinaux et cardinaux sur une même population d'électeurs.
Pour cela, les électeurs n'ont pas seulement des ordres de préférence, mais aussi des utilités sur les candidats.
Par conséquent, nous pouvons définir une population en fournissant de telles utilités.

\begin{lstlisting}
>>> pop1 = svvamp.Population(preferences_ut=
                             [[1,  1,  0], 
                              [2,  0, -1]])
\end{lstlisting}

%In this example, the first voter has utilities 1, 1 and 0 for candidates 0, 1 and 2 respectively.

Les utilités étendent l'ensemble des préférences possibles, par rapport aux ordres stricts totaux de préférence. Elles fournissent une mesure d'intensité et elle permettent à un électeur d'être indifférent entre plusieurs candidats, ce qui donne une façon pratique de manipuler des ordres faibles de préférence. Dans \mylstinline$pop1$, si le candidat~0 est le vainqueur sincère d'une élection, alors le premier électeur n'est pas intéressé par une manipulation en faveur du candidat~1, et vice versa.

%If a population is defined by utilities only, corresponding rankings will be computed the first time the attribute \mylstinline$preferences_rk$.
Cependant, pour certains systèmes de vote, les électeurs sont obligés de fournir un ordre strict de préférence: dans ce cas, chaque électeur doit casser les égalités dans ses propres préférences. Pour cette raison, si une population a été définie uniquement par ses utilités, le classement de chaque électeur est obtenu en départageant ses égalités au hasard, une fois pour toutes, la première fois où l'attribut \mylstinline$preferences_rk$ est appelé.

\begin{lstlisting}
>>> print(pop1.preferences_rk)
[[1 0 2]
 [0 1 2]]
\end{lstlisting}

%In this example, the first voter has randomly decided that each time a voting system requires a strict order, her sincere ballot will show candidate~1 first and candidate~0 second, even if she has the same utility for both these candidates. 
Le but de ce choix de spécification est que la comparaison des systèmes de vote basés sur des ordres stricts se fasse uniquement sur la base de leur comportement spécifique, sans introduire un biais dû au fait que les électeurs sincères donnent des bulletins différents aux divers systèmes de vote.

%Another interpretation of this implementation is that the first voter actually prefers candidate~1 to candidate~0, but her utility difference between them is infinitesimal, leading her not to be interested in manipulations for candidate~1 when the sincere winner $\winner$ is candidate~0.

À l'inverse, si une population est définie uniquement par des classements, \svvamp peut remplir automatiquement la matrice des utilités. Bien sûr, choisir des utilités cohérentes avec les classement est nécessairement arbitraire; par convention, \svvamp utilise, dans ce cas, des utilités égales aux scores de Borda.
\begin{lstlisting}
>>> pop2 = svvamp.Population(preferences_rk=
                             [[0, 1, 2, 3], 
                              [2, 0, 1, 3]])
>>> print(pop2.preferences_ut)
[[3 2 1 0]
 [2 1 3 0]]
\end{lstlisting}

Il est, enfin, possible de fournir des utilités et des classements simultanément, ces derniers indiquant comment chaque électeur départage ses propres égalités dans son bulletin sincère, quand un système de vote basé sur des classements est utilisé.
\begin{lstlisting}
>>> pop3 = svvamp.Population(
            preferences_ut=[[1, 1,  0],
                            [2, 0, -1]],
            preferences_rk=[[0, 1, 2], 
                            [0, 1, 2]])
\end{lstlisting}
 
Les classements doivent être cohérents avec les utilités, au sens où si un électeur~$v$ place un candidat~$c$ devant un candidat~$d$ dans son classement, alors son utilité pour~$c$ doit être supérieure ou égale à son utilité pour~$d$. Si ce n'est pas le cas, \svvamp lève une erreur.

\medskip
Certains attributs mentionnés dans la section~\ref{sec:info_pop} diffèrent selon que l'on considère des utilités ou les classements des électeurs. Par exemple, l'attribut \mylstinline$preferences_borda_ut$ est basé sur les utilités\footnote{Pour chaque électeur $v$ et candidat $c$, \mylstinline$preferences_borda_ut[v, c]$ est la somme de:
\begin{itemize}
\item 1 point pour chaque candidat $d$ tel que $v$ a une utilité strictement plus grande pour $c$ que pour $d$;
\item Et 0,5 point pour chaque candidat $d$ tel que $v$ a la même utilité pour $c$ et pour $d$.
\end{itemize}} et traite les indifférences comme telles. %It is a standardized representation for the weak orders of preferences, in the sense that any weak order of preference has a unique representation in this format.
En revanche, l'attribut \mylstinline$preferences_borda_rk$ est basé sur les classements.

\begin{lstlisting}
>>> print(pop3.preferences_borda_ut)
[[ 1.5  1.5  0. ]
 [ 2.   1.   0. ]]
>>> print(pop3.preferences_borda_rk)
[[2 1 0]
 [2 1 0]]
\end{lstlisting}

%In this example, the first voter gives the same Borda score to both candidates 0 and~1, because she has the same utility for them both.

%Some of the models used to define random populations in the next section are such that almost surely, a voter does not have the same utility for two candidates. In such cases, the end-user may call \mylstinline$preferences_borda_rk$ or \mylstinline$preferences_borda_ut$  indifferently, because they are equivalent. When indifference is possible, however, they generally do not return the same result.

Des variantes similaires avec les suffixes \mylstinline$_rk$ (basées sur les ordres stricts totaux) et \mylstinline$_ut$ (basées sur les utilités et permettant des ordres faibles) sont implantées pour la matrice des duels, la matrice des victoires et les notions Condorcet.




\subsection{Create a Population Object}\label{sec:create_pop}

Jusqu'à présent, mis à part notre exemple introductif, nous avons défini des populations manuellement, en utilisant la fonction d'initialisation de la classe Population. Ceci fournit une façon facile de définir des exemples simples. Afin de faire des études à plus large échelle, \svvamp permet également d'importer une population depuis un fichier externe ou d'utiliser une panel de modèles probabilistes pour générer des populations aléatoires.

%\subsubsection{Import a Population from an External File}

%\begin{lstlisting}
%>>> pop = svvamp.PopulationFromFile('test.csv')
%\end{lstlisting}

Importer une population depuis un fichier externe est immédiat:
%with \mylstinline$PopulationFromFile$, 
\svvamp peut lire de simples fichiers au format CSV contenant les utilités de la population ou des fichiers dans le format de la base de données PrefLib \citep{mattei2013preflib}, sur laquelle nous reviendrons dans le chapitre~\ref{sec:simulations_expe}.

Pour générer des populations artificielles, \svvamp implante une variété de cultures, c'est-à-dire de générateurs aléatoires utilisant un modèle probabiliste.

\emph{Spheroid} (ellipsoïdal) et \emph{Cubic Uniform} (cubique uniforme): ces deux modèles étendent la culture impartiale (définition~\ref{def:culture_impartiale}) aux utilités. Pour les classements, ces deux modèles sont équivalents à la culture impartiale. Nous étudierons le modèle ellipsoïdal dans le chapitre~\ref{sec:simulations_spheroidal}.

\emph{Ladder} (<<\,échelle\,>>, au sens propre): comme en culture impartiale, les électeurs sont indépendants et le modèle est anonyme et neutre (au sens où il traite les électeurs de façon symétrique, et de même pour les candidats), mais un électeur peut être indifférent entre plusieurs candidats. Ce modèle peut donc être vu comme une extension de la culture impartiale utilisant des ordres faibles. En pratique, l'utilité de chaque électeur pour chaque candidat est tirée de façon indépendante et uniforme dans un ensemble fini de valeurs (les <<\,barreaux\,>> de l'échelle). Lors de la phase de développement, cette culture est souvent utilisée pour vérifier que \svvamp{} a le comportement désiré quand les électeurs sont indifférents entre plusieurs candidats. Afin de ne pas alourdir les chapitres suivants, nous n'en ferons pas une étude détaillée dans ce mémoire.

\emph{Gaussian Well} (puits gaussien) et \emph{Euclidean box} (boîte euclidienne): ces deux modèles attribuent des positions aléatoires aux électeurs et aux candidats dans un espace euclidien appelé le \emph{spectre politique}. L'utilité d'un électeur pour un candidat est une fonction décroissante de la distance entre eux. Si la dimension du spectre politique est égale à~1, alors les préférences sont nécessairement \emph{single-peaked}~\citep[voir définition~\ref{def:single_peaked} et][]{black1958theory}. Ces modèles seront l'objet du chapitre~\ref{sec:simulations_unidim}.

\emph{Von Mises--Fisher}: ce modèle est similaire au modèle de \cite{mallows1957nonnull}, mais il est adapté à des populations définies par leurs utilités. Il y a un point spécial de l'espace des utilités, le \emph{pôle}, où la densité de probabilité est maximale, et un paramètre de concentration~$\kappa$ qui permet à \svvamp de contrôler la forme de la distribution~\citep{watson1956sphere}.
%
%\subsubsection{Extensions of the Impartial Culture}\label{sec:impartial_culture}
%
%The \emph{Impartial Culture} is commonly used in voting theory (see for example \cite{nitzan1985vulnerability}). Each voter's preferences are represented by a ranking over the candidates, drawn independently and uniformly among all possible rankings. Equivalently, this culture is characterized by three properties: voters' preferences are rankings, voters are independent and the culture is \emph{neutral} (it treats all candidates equally). 
%
%In \svvamp, two models extend the Impartial Culture to utilities: the \emph{Spheroid} model and the \emph{Cubic Uniform} model.
%
%\begin{lstlisting}
%>>> pop = svvamp.PopulationSpheroid(V=1000, 
%                                    C=10)
%\end{lstlisting}
%
%In the \emph{Spheroid} model, for each voter $v$, her utility vector \mylstinline$preferences_ut[v, :]$ is drawn independently and uniformly on the surface of the hypersphere in $\mathbb{R}^C$. Almost surely, no voter is indifferent between two distinct candidates, and voters' rankings follow the \emph{Impartial Culture}.
%
%A stretching parameter can be used to distort the spheroid along the main diagonal $[1, \ldots, 1]$ of $\mathbb{R}^C$, which allows to control the correlation between the signs of a voter's utilities (used for Approval voting), without impacting the Impartial culture assumption.
%
%\begin{lstlisting}
%>>> pop = svvamp.PopulationCubicUniform(V=1000, 
%                                        C=10)
%\end{lstlisting}
%
%In the \emph{Cubic Uniform} model, for each voter $v$ and each candidate $c$, \mylstinline$preferences_ut[v, c]$ is drawn independently and uniformly in the interval $[-1, 1]$. Voters' ordinal preferences follow the Impartial Culture, as in the Spheroid model.
%
%When studying ranking-based voting systems, both these models are equivalent and simply amount to Impartial Culture. For grade-based voting systems, they allow to study to which extent the distribution of grades impact the properties of the system, while keeping the Impartial Culture assumption.
%
%\subsubsection{Neutral Culture with Weak Orders}\label{sec:ladder}
%
%The \emph{Ladder} model relaxes one of the assumptions of the Impartial Culture: the fact that each voter has a strict order of preference.
%
%\begin{lstlisting}
%>>> pop = svvamp.PopulationLadder(V=2, C=5, 
%                                  n_rungs=21)
%>>> print(pop.preferences_ut)
%[[ 1.0  1.0  0.2 -0.7 -0.3]
% [ 0.7  0.1 -0.1 -1.0  0.2]]
%\end{lstlisting}
%
%For each voter $v$ and each candidate~$c$, \mylstinline$preferences_ut[v, c]$ is drawn independently and equiprobably in a finite set comprising \mylstinline$n_rungs$, dividing the interval [-1, 1] evenly: the set $\{-1, -1+\alpha, \ldots, 1\}$, where $\alpha = \frac{2}{\mathtt{n\_rungs} - 1}$.
%
%This model is similar to the Cubic Uniform model, but values are taken in a discrete subset of $[-1, 1]$, instead of the whole interval.
%
%Like the Cubic Uniform and Spheroid models, the Ladder model is neutral and generate independent voters, but utility ties come with non-zero probability. In the above example, the first voter is interested neither in a manipulation for candidate~0 against candidate~1, nor the opposite.
%
%\subsubsection{Polarized Culture}
%
%The \emph{Von-Mises Fisher} (VMF) model generalizes the Spheroid model: instead of drawing each voter's utility vector uniformly on the hypersphere of $\mathbb{R}^C$, we can specify a \emph{pole} --- a special point where the density of probability is maximal --- and a concentration of the probability weight around this pole.
%
%Each voter's utility vector is drawn independently on the hypersphere according to a Von Mises-Fisher distribution~\cite{watson1956sphere}. Such a distribution is characterized by a unit vector $\mathbf{u}_0$, the pole, and a concentration~$\lambda$. The density of probability of a vector $\mathbf{u}$ is:
%$$
%p(\mathbf{u}) = A e^{\lambda \mathbf{u} \cdot \mathbf{u}_0},
%$$
%where $A$ is a normalization constant.
%
%In \svvamp, the pole $\mathbf{u}_0$ and the concentration $\lambda$ are given via the arguments \mylstinline$vmf_pole$ and \mylstinline$vmf_concentration$ respectively.
%
%\begin{lstlisting}
%>>> pop = svvamp.PopulationVMFHypersphere(
%            V=100, C=10, vmf_concentration=50)
%\end{lstlisting}
%
%If the pole is not specified, as in the example above, it is drawn at random uniformly on the hypersphere, before generating voters' utility vectors.
%
Il est possible de créer une population constituée de plusieurs sous-groupes utilisant différents pôles avec différences concentrations. Un exemple d'une telle population est donné dans la figure~\ref{fig:vmf}, elle-même générée par \svvamp. Chaque point rouge représente le vecteur d'utilité d'un électeur. Les distributions de Von-Mises Fisher sont générées en utilisant l'algorithme d'\cite{ulrich1984computer} modifié par \cite{wood1994simulation}. Nous étudierons ce modèle dans le chapitre~\ref{sec:simulations_spheroidal}.

\begin{figure}
\begin{bigcenter}
\includegraphics[width=0.85\textwidth]{figures/svvamp_vmf}
\end{bigcenter}
\vspace{-.2cm}
\caption{Une population utilisant le modèle de Von Mises--Fisher. $V = 1000$ électeurs, $C = 3$ candidats, deux pôles aléatoires de même concentration~$\kappa = 50$.}\label{fig:vmf}
\vspace{-.2cm}
\end{figure}

%Qualitatively, VMF model is similar to Mallows model~\cite{mallows1957nonnull}: they both describe a culture where the population is polarized, i.e. scattered around a central point, with more or less concentration. The main difference is that Mallows model deals only with ordinal preferences, whereas VMF model is more natural when working with utilities.

%\subsubsection{Political Spectrum Cultures}
%
%There are two \emph{Political Spectrum} models in \svvamp, based on the same principle. We fix an integer $d$. Each voter $v$ is assigned a random position $\mathbf{x}(v) = (x_1(v), \ldots, x_d(v))$ and each candidate $c$ is assigned a random position $\mathbf{y}(c) = (y_1(c), \ldots, y_d(c))$ in a $d$-dimensional space, the \emph{political spectrum}. The utility of voter $v$ for candidate $c$ is $A - \delta(\mathbf{x}(v), \mathbf{y}(c))$, where $\delta(\mathbf{x}(v), \mathbf{y}(c))$ is the Euclidean distance between $\mathbf{x}(v)$ and $\mathbf{y}(c)$ and $A$ is a constant such that the mean utility on the whole population is 0% (this translation by constant $A$ is interesting for Approval voting, where the sign of utilities plays a role, but has no impact on most other voting systems)
%. This translation by constant $A$ avoids to have only negative utilities, which is interesting for the default configuration of Approval voting, where the sign of utilities play a role. It has no impact on most other voting systems.
%
%When the dimension $d$ of the political spectrum is 1, then the profile is necessarily \emph{single-peaked} \cite{black1958theory}.
%
%In the \emph{Gaussian well} model of parameters $(\sigma_1, \ldots, \sigma_d)$, each coordinate $x_i(v)$ or $y_i(c)$ is drawn independently according to a Gaussian law of standard deviation~$\sigma_i^2$.
%
%In the \emph{Euclidean box} model, each coordinate $x_i(v)$ or $y_i(c)$ is drawn independently and uniformly in an interval $[-\sigma_i, \sigma_i]$. 
%
%For both these models, it is possible to specify a \emph{shift} vector, so that the mean position of candidates is not the same as the mean position of voters.
%
%\begin{lstlisting}
%>>> pop = svvamp.PopulationGaussianWell(
%           V=100, C=5, 
%           sigma=[10, 1], shift=[1, 0])
%\end{lstlisting}
%
%In this example, voters and candidates lay in a 2-dimensional political spectrum, with different variances along dimensions and a mean shift between voters and candidates along the first dimension.
%
%Having two distinct models allows to study if some property is a qualitative consequence of the political spectrum model irrespectively of how the spectrum is populated.



\section{Elections}\label{sec:elections}

Dans \svvamp, Election est une classe abstraite. L'utilisateur final manipule toujours une de ses sous-classes implantant les élections utilisant un système de vote particulier (uninominal, assentiment, etc.), qui hérite des attributs et des méthodes de la classe Election.

%\begin{lstlisting}
%>>> pop = svvamp.PopulationSpheroid(V=5, C=4)
%>>> print(pop.preferences_rk)
%[[0 2 1 3]
% [1 3 2 0]
% [1 3 2 0]
% [2 0 1 3]
% [3 2 0 1]]
%>>> election = svvamp.Plurality(pop)
%\end{lstlisting}

%In this example, \mylstinline$election$ is a Plurality object, inheriting the attributes and methods from its superclass Election.

Dans cette section, nous verrons comment \svvamp permet d'étudier le résultat d'une élection, différentes notions de manipulation et l'indépendance des alternatives non pertinentes (IANP ou, en anglais: \emph{Independence of Irrelevant Alternatives}, \emph{IIA}).

\subsection{Result of the Election}
\vspace{0.2cm}%MAGOUILLE

Divers attributs permettent d'étudier le résultat d'une élection quand les électeurs sont sincères.

\begin{lstlisting}
>>> pop = svvamp.PopulationSpheroid(V=3, C=5)
>>> print(pop.preferences_rk)
[[0 2 3 4 1]
 [0 2 4 3 1]
 [2 1 3 4 0]]
>>> election = svvamp.Plurality(pop)
>>> print(election.ballots)
[0 0 2]
>>> print(election.scores)
[2 0 1 0 0]
>>> print(election.w)
0
\end{lstlisting}

Nous obtenons le bulletin sincère de chaque électeur, le score de chaque candidat et le vainqueur de l'élection. Les questions d'égalité seront discutées dans la section~\ref{sec:tiebreak}. \svvamp fournit également les attributs \mylstinline$candidates_by_scores_best_to_worst$ et \mylstinline$scores_best_to_worst$ pour trier les candidats en fonction de leur résultat dans l'élection. 

%This attribute provides the ballots: the first voter votes for candidate~0, the second for candidate~1, etc.
%
%\begin{lstlisting}
%>>> print(election.scores)
%[1 2 1 1]
%\end{lstlisting}
%
%This attribute provides each candidate's score: candidates 0, 1, 2 and 3 receive 1, 2, 1, and 1 votes respectively.

%\begin{lstlisting}
%>>> print(election.candidates_by_scores_best_to_worst)
%[1 0 2 3]
%>>> print(election.scores_best_to_worst)
%[2 1 1 1]
%>>> print(election.w)
%1
%\end{lstlisting}

%The election ranks candidates $1 > 0 > 2 > 3$, with respective scores $[2, 1, 1, 1]$. We will explain the tie-breaking rule in section~\ref{sec:tiebreak}. The sincere winner is candidate~1, with 2~votes.

Les types des attributs \mylstinline$ballots$, \mylstinline$scores$ et \mylstinline$scores_best_to_worst$ dépendent du système de vote. Par exemple, pour le vote par assentiment (\emph{Approval voting}), \mylstinline$ballots$ est une matrice $V \times C$ de booléens et \mylstinline$ballots[v, c]$ vaut \textbf{True} ssi l'électeur~$v$ approuve le candidat~$c$.

On pourra se reporter à la documentation pour une liste exhaustive des attributs et plus de détails sur chaque système de vote.

%\begin{lstlisting}
%>>> print(election.w_is_condorcet_winner_rk)
%True
%\end{lstlisting}
%
%The sincere winner $\winner$ is a Condorcet winner.


\vspace{0.2cm}%MAGOUILLE
\subsection{Coalitional Manipulation (CM)}
\vspace{0.2cm}%MAGOUILLE

Afin d'illustrer la manipulation par coalition, considérons l'exemple suivant. Rappelons qu'\emph{IRV} est le sigle anglophone pour le vote à tours instantanés (VTI).

\begin{lstlisting}
>>> pop = svvamp.PopulationSpheroid(V=1000, 
                                    C=10)
>>> election = svvamp.IRV(pop)
\end{lstlisting}

Examinons la manipulabilité par coalition de cette élection.
\begin{lstlisting}
>>> is_CM, log_CM = election.CM()
>>> print(is_CM)
nan
\end{lstlisting}

Pour chaque fonction, \svvamp utilise par défaut son algorithme le plus précis parmi ceux qui fonctionnent en temps polynomial. Dans le cas d'IRV (VTI), décider MC est \complexNP-complet \citep{bartholdi1991stv}, donc cet algorithme polynomial n'est pas exact. Pour cette raison, \mylstinline$is_CM$ peut être un booléen (est-ce que l'élection est manipulable ou pas), ou la valeur conventionnelle \mylstinline$nan$ signifiant que l'algorithme n'a pas été capable de décider.

On peut choisir un algorithme exact en modifiant l'attribut \mylstinline$CM_option$. 

\begin{lstlisting}
>>> election.CM_option = 'exact'
>>> is_CM, log_CM = election.CM()
>>> print(is_CM)
True
\end{lstlisting}

Pour les systèmes de vote où il y a un algorithme exact fonctionnant en temps polynomial, \mylstinline$'exact'$ est la seule option disponible.

Comme nous l'avons vu en introduction de ce chapitre, \svvamp peut préciser en faveur de quels candidats l'élection est manipulable.

\begin{lstlisting}
>>> is_CM, log_CM, candidates_CM = election.CM_with_candidates()
>>> print(candidates_CM)
[ 0.  0.  0.  1.  0.  0.  0.  0.  0.  0.]
\end{lstlisting}

\subsection{Variants of Coalitional Manipulation (ICM, UM, TM)}\label{sec:variants-of-coalitional-manipulation}

%BEGIN STUFF
%
%\begin{definition}[MU]
%Soit $\Omega$ un espace électoral où chaque électeur possède le même ensemble d'états possibles: $\forall (v, v') \in \ens{V}^2, \Omega_v = \Omega_{v'}$. On parlera de \emph{manipulation unisson} (\emph{MU}) en faveur du candidat $c$ ssi tous les électeurs qui préfèrent $c$ au vainqueur sincère participent à la manipulation et utilisent une seule et même stratégie.
%
%Ainsi, pour $(\omega,\psi) \in {\Omega}^2$, on dit que $f$ est MU dans la configuration $\omega$ vers la configuration $\psi$ ssi:
%$$
%\left\{
%\begin{array}{l}
%f(\psi) \neq f(\omega), \\
%\forall v \in \Sinc{f(\psi)}{f(\omega)}, \psi_v = \omega_v, \\
%\forall (v, v') \in \Manip{f(\psi)}{f(\omega)}^2, \psi_v = \psi_v', \\
%
%%\exists \psi_1 \in \Omega_1 \tq \forall v \in \mathcal{V}, f(\psi) \Plusque{\omega_v} f(\omega) \Rightarrow \psi_v = \psi_{strat}, \\
%%\forall v \in \mathcal{V}, \text{non}\; f(\psi) \Plusque{\omega_v} f(\omega) \Rightarrow
%%\psi_v = \omega_v. \\
%\end{array}
%\right.
%$$
%
%On définit $\MU_f$ et $\tau_\MU(f)$ comme dans la définition~\ref{def:manipulability_sbvs}.
%\end{definition}
%
%\begin{definition}[MCI]
%On parlera de \emph{manipulation par coalition ignorante} (\emph{MCI}) en faveur du candidat $c$ ssi les manipulateurs peuvent choisir une stratégie qui fait gagner $c$, quels que soient les bulletins des non-manipulateurs.
%
%Ainsi, pour $\omega \in \Omega$ et un candidat $c \in \ens{C}$, on dit que $f$ est MCI dans la configuration $\omega$ en faveur du candidat $c$ ssi il existe $\psi_{\Manip{c}{f(\omega)}} \in \Omega_{\Manip{c}{f(\omega)}}$ tel que:
%$$
%\left\{
%\begin{array}{l}
%c \neq f(\omega), \\
%\forall \phi_{\Sinc{c}{f(\omega)}} \in \Omega_{\Sinc{c}{f(\omega)}}, f(\phi_{\Sinc{c}{f(\omega)}}, \psi_{\Manip{c}{f(\omega)}}) = c.
%\end{array}
%\right.
%$$
%
%On définit $\MCI_f$ et $\tau_\MCI(f)$ comme précédemment.
%\end{definition}
%
%Il est trivial que MU, MCI et MI sont des conditions plus fortes que MC: si une configuration est MU ou MCI ou MI, alors elle est MC.
%
%END STUFF


\svvamp implante également trois variantes de MC.

On dit qu'une élection est \emph{manipulable par coalition ignorante} (MCI, ou en anglais: \emph{Ignorant-Coalition Manipulable}, \emph{ICM}) en faveur d'un candidat $c \neq \winner$ ssi les électeurs qui préfèrent~$c$ au vainqueur sincère~$\winner$ peuvent utiliser des stratégies telles que, quelles que soient les stratégies choisies par les autres électeurs, le candidat~$c$ soit déclaré vainqueur. C'est donc une notion de manipulation inspirée du critère~\cmign{}.

On dit qu'une élection est \emph{manipulable-unisson} (MU, ou en anglais: \emph{Unison-Manipulable}, \emph{UM}) en faveur du candidat~$c$ ssi il existe une stratégie telle que, quand tous les électeurs qui préfèrent strictement~$c$ au vainqueur sincère~$\winner$ utilisent cette même stratégie (pendant que les autres électeurs continuent de voter sincèrement), le candidat $c$ est déclaré vainqueur. La terminologie <<\,unisson\,>> est empruntée à~\cite{walsh2009stv}. On peut faire le parallèle avec le critère \bulmajuni{} pour l'aspect unisson, mais il est important de souligner les différences. D'une part, on impose que tous les électeurs intéressés participent à la manipulation et utilisent le même bulletin (avant tout pour permettre un calcul plus facile); d'autre part, il s'agit ici de manipulation informée (c'est-à-dire à bulletins des autres électeurs constants), alors que le critère \bulmajuni{} concerne une manipulation ignorante (qui fonctionne quels que soient les bulletins des électeurs sincères).

Enfin, on dit qu'une élection est \emph{manipulable trivialement} (MT, ou en anglais: \emph{Trivially Manipulable}, \emph{TM}) en faveur du candidat $c \neq w$ ssi, quand tous les électeurs qui préfèrent strictement $c$ à $\winner$ utilisent leur \emph{stratégie triviale} (pendant que les autres électeurs continuent de voter sincèrement), le candidat $c$ est vainqueur.

Ce que nous appelons \emph{stratégie triviale} pour l'électeur~$v$ en faveur du candidat~$c$ contre le candidat~$\winner$ dépend du type de bulletin. Pour les modes de scrutin ordinaux, c'est le bulletin où $c$ est classé premier (<<\,compromis\,>>), $\winner$ est classé dernier (<<\,enterrement\,>>), et où les autres candidats restent dans l'ordre sincère de préférence de~$v$. Pour les systèmes de vote basés sur les notes, c'est le bulletin où $v$ attribue la note maximale autorisée à~$c$ (par défaut~1) et la note minimale aux autres candidats (par défaut~$-1$).
%In such voting systems, the trivial strategy depends on $c$ but not on $\winner$.

%It could be debated whether these two strategic behaviors deserve the same name. Our point of view is that, in both cases, it is an intuitive strategy when voter $v$ wants to make $c$ win and when she knows that $\winner$ is a strong opponent, without any clue about the odds of other candidates. Collectively, this strategy requires very little coordination between the manipulators in favor of $c$: they only need to identify $\winner$ as a strong opponent (if the voting system is ordinal) and decide that they plan to manipulate for $c$ (and not for another candidate that they might also prefer to $\winner$).

La stratégie triviale paraît naturelle quand l'électeur~$v$ souhaite faire gagner~$c$ et sait que $\winner$ est un adversaire fort, sans aucun autre indice sur les chances des autres candidats. Elle requiert peu de coordination entre les manipulateurs. Pour cette raison, quand une MC est possible, la MT est un bon indicateur pour savoir si la manipulation est facile ou pas, en termes d'échange d'information entre les manipulateurs.
L'autre avantage évident de cette notion est qu'elle peut être calculée en temps polynomial (à condition que calculer le vainqueur d'une élection soit polynomial, ce qui est généralement le cas, sauf pour des systèmes de vote comme la méthode de Kemeny).

Ces trois variantes de MC ---~MCI, MU et MT~--- utilisent la même syntaxe que MC. Par exemple, MU peut être décidée avec les fonctions \mylstinline$UM$ et \mylstinline$UM_with_candidates$ et son algorithme peut être choisi avec \mylstinline$UM_option$. Comme pour MC, leur option par défaut est d'utiliser l'algorithme polynomial le plus précis disponible.


\subsection{Individual Manipulation (IM)}

%BEGIN STUFF
%
%\begin{definition}[MI]
%On parlera de \emph{manipulation individuelle} (\emph{MI}) pour une MC effectuée par une coalition constituée d'un seul manipulateur.
%
%Ainsi, pour $(\omega, \psi) \in \Omega^2$, $c \in \ens{C}$, $v_0 \in \ens{V}$, on dit que $\omega$ est MI par l'électeur $v_0$ vers la configuration $\psi$ en faveur de $c$ ssi:
%$$
%\left\{
%\begin{array}{l}
%c \neq f(\omega), \\
%f(\psi) = c, \\
%c \Plusque[v_0]{} f(\omega), \\
%%v' \in \Manip(c, f(\omega)), \\
%\forall v \in \ens{V} \setminus \{v_0\}, \psi_v = \omega_v, \\
%\end{array}
%\right.
%$$
%
%On définit $\MI_f$ et $\tau_\MI(f)$ comme précédemment.
%\end{definition}
%
%
%END STUFF

On dit qu'une élection est \emph{manipulable individuellement} (MI, ou en anglais: \emph{Individually Manipulable}, \emph{IM}) ssi un électeur~$v$, en produisant un bulletin non sincère, peut faire gagner un candidat~$c$ qu'il préfère strictement au vainqueur sincère~$\winner$ (pendant que les autres électeurs continuent de voter sincèrement).

La fonction qui fournit le plus d'information sur MI est \mylstinline$IM_full$.

\begin{lstlisting}
>>> pop = svvamp.PopulationSpheroid(V=4, C=3)
>>> election = svvamp.IRV(pop)
>>> election.w
2
>>> election.IM_option = 'exact'
>>> is_IM, log_IM, candidates_IM, voters_IM, v_IM_for_c = election.IM_full()
>>> print(is_IM)
True
>>> print(candidates_IM)
[ 1.  0.  0.]
>>> print(voters_IM)
[ 0.  0.  1.  1.]
>>> print(v_IM_for_c)
[[ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 1.  0.  0.]
 [ 1.  0.  0.]]
\end{lstlisting}

Dans cet exemple, l'élection est MI. Plus précisément, seul le premier candidat peut en bénéficier. Cette manipulation peut être accomplie par l'un quelconque des deux derniers électeurs, alors que les deux premiers ne peuvent pas ou ne sont pas intéressés.

%Several functions are variants of \mylstinline$IM_full$ that give different subsets of the same information. 
%For example, \mylstinline$IM_v$ takes a voter $v$ as argument and only computes if $v$ can perform IM. 
Si seul un sous-ensemble de ces informations est requis, des fonctions dédiées permettent de les obtenir. Elles n'effectuent que les calculs nécessaires, ce qui les rend plus rapides que \mylstinline$IM_full$. %See \svvamp's documentation for more details.

%Methods \mylstinline$IM$, \mylstinline$IM_c$, \mylstinline$IM_c_with_voters$, \mylstinline$IM_v$, \mylstinline$IM_v_with_candidates$, \mylstinline$IM_with_candidates$ and \mylstinline$IM_with_voters$ give different subsets of the same information. They perform only the necessary computations, which makes them faster.

\subsection{Independence of Irrelevant Alternatives (IIA)}

Rappelons que l'élection est \emph{indépendante des alternatives non pertinentes} (IANP, ou en anglais: \emph{Independent of Irrelevant Alternatives}, \emph{IIA}) ssi, quand on effectue l'élection avec les mêmes électeurs et tout sous-ensemble de candidats contenant le vainqueur sincère~$\winner$, celui-ci reste vainqueur.

Ici, nous étudions l'IANP pour une instance spécifique d'élection utilisant une population donnée, pas l'IANP en tant que propriété d'un système de vote en général.

\begin{lstlisting}
>>> not_IIA, log_IIA, example_subset_IIA, example_winner_IIA = election.not_IIA_full()
>>> print(not_IIA)
True
>>> print(example_subset_IIA)
[ True  True False]
>>> print(example_winner_IIA)
0
\end{lstlisting}

\mylstinline$not_IIA$ vaut \textbf{True}, ce qui signifie que l'élection viole la propriété d'IANP (par cohérence avec les méthodes de manipulation comme MC, \textbf{True} correspond au comportement <<\,indésirable\,>>). Quand c'est le cas, \mylstinline$example_subset_IIA$ fournit un sous-ensemble de candidats qui viole l'IANP: ici, le sous-ensemble contenant les candidats 0 et~1. \mylstinline$example_winner_IIA$ fournit le vainqueur correspondant, en l'occurrence le candidat~0.

Si l'élection ne viole pas IANP, les variables de contre-exemple renvoient la valeur conventionnelle \mylstinline$nan$.

\subsection{Criteria met by a Voting System}\label{sec:prop_voting_system}

Les systèmes de vote possèdent des attributs spéciaux qui représentent diverses propriétés. L'utilisateur final peut accéder à ces attributs à travers n'importe quel objet Election, mais ils concernent le système de vote lui-même, pas une instance particulière d'élection. Ils sont surtout utiles pour les développeurs de nouveaux systèmes de vote, qui peuvent renseigner ces attributs afin d'aider \svvamp à accélérer ses calculs (cf. section~\ref{sec:archi_CM}).


Par exemple, l'attribut suivant signifie que VTI (IRV) est basé sur des classements stricts, pas sur des utilités.%: the sincere ballots depend only on \mylstinline$preferences_rk$, not on utilities.


\begin{lstlisting}
>>> election = svvamp.IRV(pop)
>>> print(election.is_based_on_rk)
True
\end{lstlisting}

L'attribut suivant signifie que le système de vote est basé sur des utilités et que, pour un manipulateur unique ou pour une coalition de manipulateurs en faveur du candidat~$c$, il est optimal d'agir comme s'ils avaient une utilité de~$1$ pour~$c$ et $-1$ pour les autres candidats. Par exemple, c'est le cas pour le vote par assentiment et le vote par notation dans leur configuration par défaut\footnote{Dans la configuration par défaut pour le vote par notation et le jugement majoritaire, on considère que les vecteurs d'utilité sont définis à une transformation affine strictement positive près, comme dans le modèle classique de Von Neumann et Morgenstern (annexe~\ref{sec:sphere}). Donc prétendre qu'on a une utilité de 1 pour $c$ et $-1$ pour les autres revient à dire qu'on a strictement la meilleure utilité pour $c$ et une même utilité pour les autres.

Dans la configuration par défaut du vote par assentiment, on considère que les vecteurs d'utilité sont définis à une constante multiplicative positive près, comme dans le modèle avec limite d'approbation de la section~\ref{sec:ellipse_bigsection}, et que le bulletin sincère d'un électeur ne dépend que du signe des utilités. Donc prétendre qu'on a une utilité de 1 pour $c$ et $-1$ pour les autres revient à dire qu'on donne son assentiment à~$c$, et uniquement à~$c$.}. Bien sûr, cet attribut vaut \textbf{False} pour IRV.

\begin{lstlisting}
>>> print(election.is_based_on_ut_minus1_1)
False
\end{lstlisting}


%\begin{lstlisting}
%>>> print(election.with_two_candidates_reduces_to_plurality)
%True
%\end{lstlisting}
%
%When there are only 2~candidates, IRV is equivalent to Plurality. This attribute is used to accelerate the computation of IIA.

%\begin{lstlisting}
%>>> print(election.meets_IIA)
%False
%\end{lstlisting}
%
%IRV does not meet IIA in general. This attribute is also used to accelerate, or rather to trivialize, the computation of IIA. For example, it is True for Approval voting or Range voting (in their default configuration).

Les quatre critères suivants sont intimement liés et sont utilisés pour le calcul de MC et de ses variantes. Il s'agit des critères majoritaires principaux étudiés au chapitre~\ref{sec:criteres_majoritaires}.

\begin{lstlisting}
>>> print(election.meets_Condorcet_c_rk)
False
>>> print(election.meets_majority_favorite_c_rk)
True
>>> print(election.meets_IgnMC_c)
True
>>> print(election.meets_InfMC_c)
True
\end{lstlisting}

Dans \svvamp, plusieurs variantes de ces critères existent, en fonction de la distinction habituelle entre classement et utilités, et en fonction de questions de départage d'égalité entre les candidats. Voir la documentation pour plus de détails.

\svvamp gère les implication entre ces critères: 
%As we mentioned, these attributes are hard-coded in the definition of a voting system. However, 
par exemple, un développeur peut se contenter d'informer \svvamp qu'un certain système de vote vérifie une variante donnée de \favmaj{}. 
\svvamp sait alors quelles autres variantes de \favmaj{} et quelles déclinaisons de \cmign{} et \cminf{} cela implique.

%that for a newly developed voting system, the attribute \mylstinline$meets_Condorcet_c_rk$ is True for example. \svvamp is clever enough to know that it implies \mylstinline$meets_Condorcet_c_ut_abs$, \mylstinline$meets_majority_favorite_c_rk$, \mylstinline$meets_majority_favorite_c_ut$, \mylstinline$meets_IgnMC_c$ and \mylstinline$meets_InfMC_c$.



\vspace{0.1cm}%MAGOUILLE
\section{Implementation of CM}\label{sec:election_implem}
\vspace{0.1cm}%MAGOUILLE

Dans cette section, nous nous concentrons sur l'implantation de MC, qui illustre au mieux les techniques générales utilisées dans \svvamp.

\subsection{Minimizing computation}

Lors du calcul de MC et de ses variantes, si l'élection n'est pas manipulable, il est généralement nécessaire de boucler sur tous les candidats pour le prouver. Mais si l'élection est manipulable, il est suffisant de prouver la manipulation en faveur d'un seul candidat. Pour cette raison, il est intéressant de deviner pour quels candidats une manipulation est la plus vraisemblable et de tester ces candidats en premier. Dans les méthodes génériques de la classe Election, on utilise une heuristique simple: les candidats sont examinés dans l'ordre décroissant du nombre de manipulateurs qui leur correspond. Ce comportement peut facilement être redéfini quand on implante un système de vote en particulier.
%This behavior can be modified for a specific voting system easily by changing the way the attribute \mylstinline$losing_candidates$ (of type list) is computed.

%Of course, before launching computations for a candidate, \svvamp checks that at least one manipulator is interested.

De manière générale, \svvamp essaie d'être aussi paresseux que possible. Cela signifie par exemple: 1. ne pas faire de calculs inutiles et 2. ne pas faire le même calcul deux fois.

Ceci peut être illustré par l'exemple suivant.
\begin{lstlisting}
>>> is_CM, log_CM = election.CM()
>>> print(is_CM)
True
>>> is_CM, log_CM, candidates_CM = election.CM_with_candidates()
>>> print(candidates_CM)
[0. 0. 1. 0. 1.]
\end{lstlisting}

\begin{enumerate}
\item Lorsque \mylstinline$CM$ est appelé, voici une exécution possible: \svvamp examine le candidat 0 en premier, parce qu'il a le plus de manipulateurs, mais la manipulation est prouvée impossible. Puis \svvamp examine le candidat~2 et trouve une manipulation. \svvamp arrête le calcul et décide que \mylstinline$is_CM$ est \textbf{True}.
\item Lorsque \mylstinline$CM_with_candidates$ est appelé, \svvamp se rappelle le résultat du calcul pour les candidats 0 et~2 et il effectue le calcul uniquement pour les autres candidats.
\end{enumerate}

\subsection{Number of Manipulators}\label{sec:bounds}

Quand on calcule MU ou MT pour un candidat donné~$c$, on utilise un ensemble fixe de manipulateurs: les électeurs qui préfèrent effectivement $c$ au vainqueur sincère~$\winner$. Cependant, MC et MCI fonctionnent différemment. En fait, pour étudier MC ou MCI en faveur d'un candidat~$c$, \svvamp traite la question suivante. Étant donné la sous-population des électeurs sincères, c'est-à-dire ceux qui ne préfèrent pas strictement $c$ à~$\winner$, quel est le nombre de manipulateurs minimal qu'il faut ajouter pour effectuer la manipulation\footnote{Cette question est appelée le problème d'optimisation non-pondéré constructif par coalition (\emph{Constructive Coalitional Unweighted Optimization} problem) par \cite{zuckerman2009algorithms}. Il permet de décider MC pour tous les systèmes de vote actuellement implantés dans \svvamp.}? Notons cet entier~$x_c$.

Pendant le calcul, \svvamp maintient à jour une borne inférieure et une borne supérieure de~$x_c$. Dès que la borne inférieure devient plus grande que le nombre de manipulateurs, la manipulation est prouvée impossible. À l'inverse, dès que la borne supérieure devient inférieure ou égale au nombre de manipulateurs, la manipulation pour $c$ est prouvée.

Ce mécanisme permet à \svvamp de combiner différents algorithmes et d'accélérer les calculs, même quand l'attribut \mylstinline$CM_option$ a la valeur \mylstinline$'exact'$. Par exemple, en utilisant VTI en mode exact, \svvamp commence par utiliser un algorithme polynomial approché pour diminuer l'intervalle entre les bornes (nous y reviendrons en section~\ref{sec:vti_implem}). Si cela suffit à décider MC, le calcul s'arrête. Sinon, l'algorithme exact non-polynomial est utilisé et il exploite les bornes déjà connues pour accélérer le calcul.

%Here is a typical course of action:
%\begin{enumerate}
%\item Perform preliminary checks. If this allows to decide MC, then return.
%\item Else, perform the polynomial approximate algorithm implemented for the voting system under study. If this allows to decide MC, then return.
%\item Else, perform the exact algorithm implemented for this voting system, which can exploits the bounds already known to accelerate computation.
%\end{enumerate}

\subsection{Anonymity and Resoluteness}\label{sec:tiebreak}

Le mécanisme d'ajout de manipulateurs que nous venons de décrire explique un important choix de \svvamp: les modes de scrutin doivent être \emph{anonymes}, au sens où ils traitent tous les électeurs de la même façon. Ce choix permet à \svvamp de travailler sur le nombre de manipulateurs, pas sur leur identité. Si les électeurs avaient des poids différents, beaucoup de problèmes faciles deviendraient difficiles: par exemple, même pour un nombre fixe de 3~candidats, décider MC avec des électeurs pondérés pour Borda, Maximin, VTI ou Veto est \complexNP-complet \citep{conitzer2002fewcandidates, conitzer2003many, conitzer2007when}, alors qu'avec des électeurs non pondérés, le problème est dans~\complexP{} (par rapport au nombre d'électeurs~$V$).

Nous supposons également que les modes de scrutin sont déterministes et résolus: ils élisent un unique candidat. Sinon, définir la manipulation est une question en soi, parce qu'il est nécessaire de préciser comment les préférences sur les candidats s'étendent à des préférences sur les ensembles de candidats (ou les distributions de probabilité sur les candidats), ce qui peut être fait d'une infinité de façons. On pourra en trouver des exemples chez \cite{gardenfors1976manipulation, gibbard1978lotteries, duggan2000manipulability}. 
Utiliser des modes de scrutin résolus permet à \svvamp de décider MC et ses variantes en bouclant sur les candidats susceptibles de bénéficier d'une manipulation (c.a.d. tous sauf le vainqueur sincère), en considérant pour chacun l'ensemble des électeurs intéressés par le candidat en question. En revanche, si le mode de scrutin renvoie un sous-ensemble de candidats (resp. une distribution de probabilité sur les candidats), alors il est déraisonnable (resp. impossible) de boucler sur tous les résultats possibles.

Puisque les modes de scrutin sont anonymes et résolus, ils sont nécessairement non neutres en général (voir proposition~\ref{thm:neutr_anon_cns}): en effet, ils doivent renvoyer un unique vainqueur, y compris dans des configurations totalement symétriques comme l'exemple minimal habituel de paradoxe de Condorcet (avec $V=3$ et $C=3$). Dans \svvamp, la règle de départage habituelle est que le candidat avec le plus petit index est favorisé. Par exemple, s'il y a une égalité entre les candidats 0 et~1, alors le candidat~0 est déclaré vainqueur. Nous avons choisi cette règle pour sa simplicité: avec des règles plus compliquées, certains problèmes de manipulation habituellement dans \complexP{} deviennent \complexNP-complets \citep{obraztsova2011ties, obraztsova2012complexity, aziz2013ties}. Cependant, il n'y a pas de limitation architecturale dans \svvamp qui empêche d'implanter des systèmes de vote utilisant d'autres règles de départage.



\subsection{CM sub-functions}\label{sec:archi_CM}

\svvamp est écrit de façon modulaire, en utilisant une approche orientée objet qui est naturelle dans le langage Python. Par exemple, la fonction \mylstinline$CM$ (ou sa version détaillée \mylstinline$CM_with_candidates$) définie dans la classe Election appelle, en fait, un certain nombre de sous-fonctions spécifiques.
% Figure~\ref{fig:modularity} shows the main sub-functions of CM used in class Election and their relation of call.
%This diagram means that \mylstinline$CM$ calls \mylstinline$_CM_initialize_general$ and \mylstinline$_compute_CM$, etc. 
Chacune de ces sous-fonctions peut être redéfinie dans la sous-classe qui implante un mode de scrutin en particulier, tout en conservant les autres sous-fonctions par défaut.

À titre indicatif, on peut diviser les sous-fonctions en trois catégories: tests préliminaires généraux, tests préliminaires dédiés à un candidat, noyau de calcul.

%\begin{lstlisting}
%CM
%    _CM_initialize_general
%        _CM_preliminary_checks_general
%            _CM_preliminary_checks_general_subclass
%    _compute_CM
%        _compute_CM_c
%            _CM_initialize_c
%                _CM_preliminary_checks_c
%                    _CM_preliminary_checks_c_subclass
%            _CM_main_work_c
%                _CM_main_work_c_lazy
%                _CM_main_work_c_exact
%            _CM_conclude_c
%\end{lstlisting}

%\begin{figure}
%\begin{center}
%{\small
%\begin{tikzpicture}[xscale=0.5,yscale=0.65]
%   \node (M') at (3+0.5,-12) {};
%   \node[draw, right, fill=white] (M) at (3,-12) {\strut\mylstinline$_CM_conclude_c$};
%    \node (L') at (4+0.5,-11) {};
%    \node[draw, right, fill=white] (L) at (4,-11) {\strut\mylstinline$_CM_main_work_c_exact$};
%    \node (K') at (4+0.5,-10) {};
%    \node[draw, right, fill=white] (K) at (4,-10) {\strut\mylstinline$_CM_main_work_c_lazy$};
%   \node (J') at (3+0.5,-9) {};
%   \draw[->,  >=latex] (J') |- (K);
%   \draw[->,  >=latex] (J') |- (L);
%   \node[draw, right, fill=white] (J) at (3,-9) {\strut\mylstinline$_CM_main_work_c$};
%     \node (I') at (5+0.5,-8) {};
%     \node[draw, right, fill=white] (I) at (5,-8) {\strut\mylstinline$_CM_preliminary_checks_c_subclass$};
%    \node (H') at (4+0.5,-7) {};
%    \draw[->,  >=latex] (H') |- (I);
%    \node[draw, right, fill=white] (H) at (4,-7) {\strut\mylstinline$_CM_preliminary_checks_c$};
%   \node (G') at (3+0.5,-6) {};
%   \draw[->,  >=latex] (G') |- (H);
%   \node[draw, right, fill=white] (G) at (3,-6) {\strut\mylstinline$_CM_initialize_c$};
%  \node (F') at (2+0.5,-5) {};
%  \draw[->,  >=latex] (F') |- (G);
%  \draw[->,  >=latex] (F') |- (J);
%  \draw[->,  >=latex] (F') |- (M);
%  \node[draw, right, fill=white] (F) at (2,-5) {\strut\mylstinline$_compute_CM_c$};
% \node (E') at (1+0.5,-4) {};
% \draw[->,  >=latex] (E') |- (F);
% \node[draw, right, fill=white] (E) at (1,-4) {\strut\mylstinline$_compute_CM$};
%   \node (D') at (3+0.5,-3) {};
%   \node[draw, right, fill=white] (D) at (3,-3) {\strut\mylstinline$_CM_preliminary_checks_general_subclass$};
%  \node (C') at (2+0.5,-2) {};
%  \draw[->,  >=latex] (C') |- (D);
%  \node[draw, right, fill=white] (C) at (2,-2) {\strut\mylstinline$_CM_preliminary_checks_general$};
% \node (B') at (1+0.5,-1) {};
% \draw[->,  >=latex] (B') |- (C);
% \node[draw, right, fill=white] (B) at (1,-1) {\strut\mylstinline$_CM_initialize_general$};
%\node (A') at (0+0.5,0) {};
%\draw[->,  >=latex] (A') |- (B);
%\draw[->,  >=latex] (A') |- (E);
%\node[draw, right, fill=white] (A) at (0,0) {\strut\mylstinline$CM$};
%\end{tikzpicture}
%}
%\end{center}
%\caption{Architecture of sub-functions for CM}\label{fig:modularity}
%\end{figure}

Les tests préliminaires généraux ont pour but de décider MC immédiatement si possible.
\begin{itemize}
\item Si le système de vote vérifie \favmaj{} (section~\ref{sec:prop_voting_system}) et si $\winner$ est un favori majoritaire\footnote{Pour chaque test préliminaire, il y a diverses variantes qui dépendent de questions de départage d'égalité. Par souci de concision et de clarté, nous ne décrivons pas ces variantes ici. Pour plus de détails, on pourra consulter le code de la classe Election.}, alors MC vaut \textbf{False}.
\item Si le système de vote vérifie \cond{} et si $\winner$ est vainqueur de Condorcet résistant, alors MC vaut \textbf{False}.
\item Si le système de vote vérifie \cminf{} et si $\winner$ n'est pas Condorcet-admissible, alors MC vaut \textbf{True}.
\item Si MT, MU ou MCI vaut \textbf{True}, alors MC vaut \textbf{True}.  %By itself, this preliminary check motivates the implementation of TM.
\end{itemize}
%For the last check, TM, UM and ICM are called sequentially. Remind that by default, they rely on polynomial algorithms.
%For instance, TM is computed exactly (cf \ref{sec:variants-of-coalitional-manipulation}), while by default UM will often limit its computation to its own pre-checks. 
%Empirically, TM is the most useful of the three variants for this check.

Si nécessaire, \svvamp effectue des tests préliminaires qui sont dédiés à la manipulation en faveur d'un candidat donné~$c$.
\begin{itemize}
\item Si le système de vote vérifie~\cminf{}, alors il est suffisant d'avoir plus de manipulateurs que d'électeurs sincères.
\item Si le système de vote vérifie \favmaj{}, alors il est nécessaire d'avoir assez de manipulateurs pour empêcher le vainqueur sincère~$\winner$ d'apparaître comme un favori majoritaire.
\item Si le système de vote vérifie \cond{}, alors il est nécessaire d'avoir assez de manipulateurs pour empêcher $\winner$ d'apparaître comme un vainqueur de Condorcet (on peut faire le parallèle entre ce test et la notion de vainqueur de Condorcet résistant).
\item Si MT ou MU est possible pour~$c$, alors MC est possible pour $c$.
\item Le nombre de manipulateurs suffisant pour MCI est également suffisant pour MC.
\end{itemize}

À ce stade, si l'attribut \mylstinline$CM_option$ a la valeur \mylstinline$'lazy'$, l'algorithme s'arrête, que la solution ait été trouvée ou pas. Dans ce dernier cas, on renvoie la valeur conventionnelle \mylstinline$nan$.

Si l'attribut \mylstinline$CM_option$ a la valeur \mylstinline$'exact'$, alors la classe Election possède un algorithme par défaut, qui peut être redéfini dans chaque système de vote pour plus d'efficacité.

Si l'attribut \mylstinline$is_based_on_rk$ vaut \textbf{True}, l'algorithme exact par défaut de la classe générique Election utilise la force brute: les manipulateurs essaient tous les bulletins possibles. 
Pour un candidat~$c$, en notant $n_c$ le nombre de manipulateurs pour $c$ contre $\winner$, cet algorithme par défaut a une complexité en temps de l'ordre de $(C!)^{n_c}$ (multiplié par un polynôme et par le temps nécessaire pour calculer le vainqueur d'une élection), ce qui le rend utilisable seulement pour de petites configurations\footnote{La complexité est en fait un peu inférieure car on teste les bulletins possibles à permutation près des manipulateurs.}.

Si l'attribut \mylstinline$is_based_on_ut_minus1_1$ vaut \textbf{True}, l'algorithme exact par défaut est évident: les manipulateurs ont simplement besoin de tester le bulletin sincère correspondant à une utilité de 1 pour $c$ et une utilité de $-1$ pour tous les autres candidats. Ceci fonctionne en temps polynomial (multiplié par le temps nécessaire pour calculer le vainqueur d'une élection).

Dans les autres cas (c'est-à-dire pour un système qui ne repose pas sur des classements et où la stratégie optimale de manipulation pour un certain candidat~$c$ ne consiste pas à agir comme si on avait une utilité de 1 pour $c$ et $-1$ pour les autres candidats), cette méthode lève une erreur NotImplemented.

Dans la sous-classe qui implante un système de vote en particulier, la sous-fonction implantant l'algorithme exact est fréquemment redéfini pour bénéficier d'un algorithme plus efficace que la force brute.


%\section{Implementation of Methods in Class Election}\label{sec:election_methods_implem}

%In the previous section, we presented general considerations on the architecture of class Election. Now, we present the generic algorithms implemented in the superclass Election for each type of manipulation and IIA. For some of the voting systems, these methods are overridden to benefit of more efficient algorithms.
%
%When studying CM and variants for a candidate~$c$, we note $n_m$ the number of manipulators and $n_s$ the number of sincere voters (their dependence on~$c$ is not written). We will note CM($c$) (resp. TM($c$), UM($c$), ICM($c$)) the boolean that is True iff the election is CM (resp. TM, UM, ICM) in favor of~$c$.
%
%\subsection{Implementation of TM}
%
%\textbf{General preliminary checks:} if the voting system meets \favmaj{} and if $\winner$ is a majority favorite\footnote{For all preliminary checks, there is a variety of variants depending on notions of tie-breaking. For the sake of conciseness and clarity, we do not develop these variants in this paper. For more details, see the code of class Election.}, then TM is False. 
%
%\textbf{Preliminary checks for candidate $c$:} none.
%
%No other preliminary checks are implemented, because TM is generally easy to compute.
%
%If the attribute \mylstinline$is_based_on_rk$ or the attribute \mylstinline$is_based_on_ut_minus1_1$ is True, then the generic exact algorithm is directly derived from the definition of TM. It runs in polynomial time (provided computing the winner of an election can be done in polynomial time).
%
%Otherwise, in the generic methods of class Election, the option \mylstinline$'lazy'$ is used.
%
%
%\subsection{Implementation of UM}
%
%\textbf{General preliminary checks:}
%\begin{itemize}
%\item If the voting system meets \favmaj{} and if $\winner$ is a majority winner, then UM is False.
%\item If the voting system meets \cond{} and if $\winner$ is \emph{resistant-Condorcet winner}\footnote{A candidate $\winner$ is a \emph{resistant Condorcet winner} iff for any other candidate~$c$, voters who strictly prefer $c$ to $\winner$ (in the sense of utilities) cannot prevent $\winner$ from appearing as a Condorcet winner. Cf. \svvamp's documentation for more details.}, then UM is False.
%\item If the voting system meets \favmaj{} and $\winner$ is not \emph{Condorcet-admissible}\footnote{A candidate $\winner$ is \emph{Condorcet-admissible} iff for any candidate~$c$, there is not a strict majority of voters who strictly prefer $c$ to $\winner$ (in the sense of utilities). When voters have no ties in their preferences, this notion is equivalent to the usual notion of \emph{weak Condorcet winner}. Cf. \svvamp's documentation for more details.}, then UM is True.
%\end{itemize}
%
%\textbf{Preliminary checks for candidate $c$:}
%\begin{itemize}
%\item If the voting system meets \favmaj{} and if $n_m > V / 2$, then UM($c$) is True.
%\item If the voting system meets \cond{} and if manipulators cannot prevent $\winner$ from appearing as a Condorcet winner, then UM($c$) is False.
%\end{itemize}
%
%%If \mylstinline$UM_option$ is \mylstinline$'lazy'$, then no other computation is performed.
%
%If the attribute \mylstinline$is_based_on_rk$ is True, the default exact algorithm uses brute force: manipulators try all the possible ballots\footnote{There is a small optimization here. If ballots were tested in lexicographic order, we would test all ballots ranking candidate~0 first before any ballot with candidate~1 first. However, in many voting systems, the first candidate is quite important. For this reason, we explore possible rankings in a succession that alternates top-ranked candidates. Cf. the documentation of function \mylstinline$compute_next_borda_clever$.}. This default algorithm has a time complexity of order $C!$ (multiplied by a polynomial and by the time needed to compute the winner of an election), which makes it only usable for small populations.
%
%If the attribute \mylstinline$is_based_on_ut_minus1_1$ is True, manipulators just need to test the sincere ballot corresponding to an utility 1 for $c$ and an utility $-1$ for all other candidates. This runs in polynomial time (multiplied by the time needed to compute the winner of an election).
%
%
%\subsection{Implementation of ICM}
%
%Here, $x_c$ denotes the minimal number of manipulators needed to perform ICM for candidate~$c$, knowing that $n_s$ sincere voters can choose their strategy after them.
%
%\textbf{General preliminary checks:} if the voting system meets \cminf{} and if $\winner$ is a Condorcet winner, then ICM is False.
%
%\textbf{Preliminary checks for candidate $c$:}
%\begin{itemize}
%\item If the voting system meets \cminf{}, then $x_c \geq n_s$, i.e. it is necessary to have at least as many manipulators as sincere voters.
%\item If the voting system meets \cmign{}, then $x_c \leq n_s + 1$, i.e. it is sufficient to have more manipulators than sincere voters.
%\end{itemize}
%
%The default algorithm in superclass Election is \mylstinline$'lazy'$: it does nothing but these preliminary checks. But for many voting systems, it is enough. Indeed, if the voting system meets a variant of \cmign{} with ties, then this generic algorithm is exact. If the voting system meets only the basic version of \cmign{} defined in section~\ref{sec:prop_voting_system}, then this generic algorithm can decide ICM exactly up to ties (which can happen only if the number of voters $V$ is even).

%\subsection{Implementation of CM}\label{sec:implemCM}
%
%Here, $x_c$ denotes the minimal number of manipulators needed to perform CM for candidate~$c$, knowing the strategies of the $n_s$ sincere voters.
%
%\textbf{General preliminary checks:}
%\begin{itemize}
%\item If the voting system meets \favmaj{} and if $\winner$ is a majority favorite\footnote{For all preliminary checks, there is a variety of variants depending on notions of tie-breaking. For the sake of conciseness and clarity, we do not develop these variants in this paper. For more details, see the code of class Election.}, then CM is False.
%\item If the voting system meets \cond{} and if $\winner$ is \emph{resistant-Condorcet winner}\footnote{A candidate $\winner$ is a \emph{resistant Condorcet winner} iff for any other candidate~$c$, voters who strictly prefer $c$ to $\winner$ (in the sense of utilities) cannot prevent $\winner$ from appearing as a Condorcet winner. Cf. \svvamp's documentation for more details.}, then CM is False.
%\item If the voting system meets \cminf{} and $\winner$ is not \emph{Condorcet-admissible}\footnote{A candidate $\winner$ is \emph{Condorcet-admissible} iff for any candidate~$c$, there is not a strict majority of voters who strictly prefer $c$ to $\winner$ (in the sense of utilities). When voters have no ties in their preferences, this notion is equivalent to the usual notion of \emph{weak Condorcet winner}. Cf. \svvamp's documentation for more details.}, then CM is True.
%\item If either TM, UM or ICM is True, then CM is True. By itself, this preliminary check motivates the implementation of TM.
%\end{itemize}
%
%\textbf{Preliminary checks for candidate $c$:}
%\begin{itemize}
%\item If the voting system meets \cminf{}, then $x_c \leq n_s + 1$, i.e. it is sufficient to have more manipulators than sincere voters.
%\item If the voting system meets \favmaj{}, then it is necessary to have enough manipulators to prevent the sincere winner $\winner$ from appearing as a majority favorite.
%\item If the voting system meets \cond{}, then it is necessary to have enough manipulators to prevent $\winner$ from appearing as a Condorcet winner.
%\item If TM or UM is possible for $c$, then $x_c \leq n_m$, i.e. it is sufficient to have as many manipulators as there are actually.
%\item The sufficient number of manipulators for ICM is also a sufficient number of manipulators for CM.
%\end{itemize}
%
%If the attribute \mylstinline$is_based_on_rk$ is True, the default exact algorithm uses brute force: manipulators try all the possible ballots. This default algorithm has a time complexity of order $(C!)^{n_m}$ (multiplied by a polynomial and by the time needed to compute the winner of an election), which makes it only usable for very small populations.
%
%If the attribute \mylstinline$is_based_on_ut_minus1_1$ is True, the default exact algorithm is straightforward: it is the same as for UM. It runs in polynomial time (multiplied by the time needed to compute the winner of an election).

%\subsection{Implementation of IM}\label{sec:implem_IM}
%
%In large elections, it is frequent that a single voter has not even the power to change the result of the election: she is not \emph{pivotal}. In that case, it is not necessary to examine IM for that voter. The general architecture of IM uses the attribute \mylstinline$v_might_IM_for_c$, having the following semantics: if \mylstinline$v_might_IM_for_c[v, c]$ is False, then IM by voter~$v$ for candidate~$c$ is impossible (the converse does not hold). In the superclass Election, this attribute is simply a matrix of True, so it carries no information. But in the subclass of specific voting systems, it is typically overridden by pivotality tests.
%
%%Test first if the voter wants to manipulate for $c$.
%
%If the voting system is ordinal and if voter $v + 1$ has the same ordinal preferences as voter $v$, then \svvamp does not run the computations again for voter $v + 1$ but simply copies the results obtained for voter $v$. This is especially useful for a large number of voters and a small number of candidates (typically if $V$ is at least the order of magnitude of $C!$), because in that case, voters are more likely to have identical ordinal preferences. To benefit most from this acceleration, as soon as an Election object is created on a population, the sorting method \mylstinline$ensure_voters_sorted_by_rk$ is automatically applied to the population.
%
%If the attribute \mylstinline$is_based_on_rk$ is True, the default exact algorithm uses brute force:each manipulator try all the possible ballots. This default algorithm has a time complexity of order $C!$ (multiplied by a polynomial and by the time needed to compute the winner of an election), which makes it only usable for small populations.
%
%If the attribute \mylstinline$is_based_on_ut_minus1_1$ is True, the default exact algorithm is straightforward and runs in polynomial time (multiplied by the time needed to compute the winner of an election).


%\subsection{Implementation of IIA}
%
%\textbf{Preliminary tests:}
%\begin{itemize}
%\item If the voting system meets IIA in general, i.e. if the attribute \mylstinline$meets_IIA$ is True, then IIA is True.
%\item If the voting system meets \cond{} and if $\winner$ is a Condorcet winner, then IIA is True.
%\item If the voting system meets \favmaj{} and if $\winner$ is a majority favorite, then IIA is True.
%\end{itemize}
%
%The generic algorithm in Election class uses the option \mylstinline$IIA_subset_maximum_size$, which can be a positive integer or $+\infty$. If the preliminary tests do not decide IIA, then the default algorithm loops over subsets of candidates including~$\winner$, whose size does not exceed \mylstinline$IIA_subset_maximum_size$.
%
%If \mylstinline$IIA_subset_maximum_size$ is $+\infty$, then this algorithm is exact but its time complexity is of order $2^C$.
%
%If \mylstinline$IIA_subset_maximum_size$ is finite, then this algorithm runs in polynomial but it is not exact: if it does not find an example of subset violating IIA, it is not proven that the election meets IIA. In that case, the conventional answer \mylstinline$nan$ is returned.


\subsection{Performance of the generic polynomial algorithm}

%Performances of TM. Figure with voting systems where no other algorithm is available. Baldwin, ICRV, CondorcetSumDefeats, IRVDuels, IteratedBucklin, Kemeny, Nanson, RankedPairs


\begin{figure}
	\begin{bigcenter}
		\includegraphics[width=\relativewidth\textwidth]{fig_simu/perf_generic_algos.eps}
		\vspace{-.5cm}
		\caption{Performances de l'algorithme polynomial par défaut pour MC. Modèle \emph{Spheroid}, $V =  33$.}\label{fig:poly_performance}
	\end{bigcenter}
	\vspace{-.7cm}
\end{figure}

%\begin{figure}
%\begin{center}
%\includegraphics[width=10cm]{general_method_TM.pdf}
%\caption{Performances of the default polynomial algorithm for CM. Spheroid model, $V =  33$.}\label{fig:poly_performance}
%\end{center}
%\end{figure}

En utilisant l'option \mylstinline$'lazy'$, l'algorithme générique pour MC fonctionne en temps polynomial mais peut ne pas décider. La figure~\ref{fig:poly_performance} donne son efficacité mesurée sur des systèmes de vote pour lesquels aucun algorithme spécifique n'est implanté dans \svvamp\footnote{Parmi les systèmes représentés dans la figure~\ref{fig:poly_performance}, on sait que le problème de la manipulation est \complexNP-difficile pour les méthodes de Baldwin et Nanson \citep{narodytska2011nanson, davies2014complexity}, PO \citep{xia2009unweighted, hemaspaandra2012schulze, parkes2012schulze} et la méthode de Kemeny. Pour VTID, CSD et BI, la question est ouverte.}. Pour ces systèmes de vote, seule la règle de calcul du vainqueur est fournie à \svvamp, ainsi que les propriétés de base du système de vote (\mylstinline$is_based_on_rk$, \mylstinline$meets_Condorcet_c$, etc.). Par conséquent, l'algorithme générique \mylstinline$'lazy'$ repose avant tout sur les tests préliminaires exposés en \ref{sec:archi_CM}, dont le plus important est MT.

Pour obtenir la figure~\ref{fig:poly_performance}, pour chaque valeur de $C$, $10\,000$ populations aléatoires ont été générées par le modèle \emph{Spheroid} avec $V = 33$. La valeur sur l'axe des ordonnées est le ratio de populations pour lesquelles la fonction \mylstinline$CM$ a renvoyé la valeur \mylstinline$nan$, signifiant qu'elle n'a été capable de prouver ni MC ni sa négation.

%On voit que l'algorithme paresseux générique est assez efficace pour décider CM, sauf pour le système de vote \emph{ICRV} (une des variantes Condorcet d'IRV). Empiriquement, en comparant avec l'algorithme exact, nous avons remarqué que l'algorithme paresseux est efficace pour prouver CM, mais l'est moins pour prouver $\neg$CM. Dans les simulations conduisant à cette figure, sauf pour ICRV, les fréquences de CM étaient élevées, ce qui explique les bonnes performances pour les autres systèmes de vote.
On voit que l'algorithme paresseux générique est assez efficace pour décider~MC. Empiriquement, en comparant avec l'algorithme exact, nous avons remarqué que l'algorithme paresseux est efficace pour prouver MC, mais l'est moins pour prouver la négation de~MC. Afin de ne pas faire de publicité mensongère, il nous faut mentionner que dans les simulations conduisant à cette figure, les fréquences de MC étaient relativement élevées (comme nous le verrons en reprenant cet exemple dans la section~\ref{sec:sphere_C}), ce qui explique les bonnes performances de l'algorithme générique approché.


\section{Algorithms for speci?c voting systems}\label{sec:voting_systems_implem}

Pour certains modes de scrutin, des algorithmes spécifiques sont implantés. Dans cette section, nous donnons une vue d'ensemble de ces algorithmes.

%\begin{table*}
%\begin{center}
%\begin{tabular}{|l|c|c|c|}
%\hline
%\textbf{Voting system}      & \textbf{Polynomial} & \textbf{Exact} & \textbf{Remark} \\ \hline
%Range Voting       & \multicolumn{2}{c|}{Easy} & \\ \hline
%Majority Judgment  & \multicolumn{2}{c|}{Easy} & \\ \hline
%Approval           & \multicolumn{2}{c|}{Easy} & \\ \hline
%Bucklin rule       & \multicolumn{2}{c|}{\cite{xia2009unweighted}}  & \\ \hline
%Plurality          & \multicolumn{2}{c|}{Easy} & \\ \hline
%Two-Round System   & \multicolumn{2}{c|}{Easy} & \\ \hline
%Veto               & \multicolumn{2}{c|}{Easy} & \\ \hline
%Borda              & \cite{zuckerman2009algorithms} & Generic algorithm & NP-complete, even for 2~manipulators \\ \hline
%Maximin            & \cite{zuckerman2011maximin} & Generic algorithm & NP-complete, even for 2~manipulators \\ \hline
%Schulze            & \cite{gaspers2013schulze} & Generic algorithm & The polynomial algorithm is exact up to ties \\ \hline
%Coombs             & Original heuristic & Adapted from \cite{walsh2009stv} & \\ \hline
%Exhaustive Ballot  & Original heuristic & Adapted from \cite{walsh2009stv} & \\ \hline
%IRV                & Original heuristic & Adapted from \cite{walsh2009stv} & NP-complete, even for 1~manipulator \\ \hline
%Condorcet-IRV      & Original heuristic & Adapted from \cite{walsh2009stv} & \\ \hline
%%Exhaustive ballot
%%IRV
%%Condorcet-IRV
%\end{tabular}
%\caption{Specific algorithms}
%\end{center}
%\end{table*}

%\subsection{Cardinal Voting Systems}

Pour le vote par notation, le jugement majoritaire, le vote par assentiment, la méthode de Bucklin, l'uninominal, l'uninominal à deux tours et veto, MC est calculée exactement en temps polynomial. Pour la méthode de Bucklin, nous utilisons un algorithme de~\cite{xia2009unweighted}. Pour les autres, l'algorithme de manipulation est évident.

Pour la méthode de Schulze, nous utilisons un algorithme de~\cite{gaspers2013schulze}, qui fonctionne en temps polynomial. L'article original prouve que cet algorithme est exact pour le \emph{problème à plusieurs vainqueurs}, c'est-à-dire si les manipulateurs ont pour but qu'un certain candidat~$c$ fasse partie des \emph{vainqueurs potentiels} (voir la définition de ce terme dans la définition de la méthode de Schulze, en section~\ref{sec:zoologie_mds_condorcet}). Il en est de même pour le \emph{problème à un seul vainqueur}, c'est-à-dire si les manipulateurs ont pour but qu'un certain candidat~$c$ soit l'unique vainqueur potentiel (c'est-à-dire vainqueur pour toute règle de départage). Dans \svvamp, il a une marge d'erreur d'un manipulateur à cause de la règle de départage. Par conséquent, il peut arriver (relativement rarement) que le simulateur renvoie \mylstinline"nan" quand on lui demande de décider la manipulabilité.

Pour la méthode de Borda, décider MC est \complexNP{}-complet, même quand il y a seulement 2~manipulateurs~\citep{betzler2011unweighted, davies2011complexity}. Nous utilisons un algorithme d'approximation de \cite{zuckerman2009algorithms}, qui possède une marge d'erreur d'un manipulateur.

Pour Maximin, décider MC est \complexNP{}-complet, même quand il y a seulement 2~manipulateurs \citep{xia2009unweighted}. Nous utilisons un algorithme d'approximation de \cite{zuckerman2011maximin}, qui a un facteur d'erreur multiplicatif de $\frac{5}{3}$ sur le nombre de manipulateurs nécessaire.

Pour la méthode de Coombs, il y a deux options possibles pour MC: \mbox{\mylstinline$'fast'$} et \mylstinline$'exact'$. En mode exact, notre algorithme est similaire à celui utilisé par \cite{walsh2009stv} pour IRV. Sa complexité en temps est d'ordre~$C!$. En mode rapide, nous utilisons une heuristique originale que nous ne décrirons pas en détails mais dont le principe est similaire à celui utilisé pour VTI, que nous décrirons dans la section~\ref{sec:vti_implem}. La question est cependant plus simple que pour VTI car on peut remarquer que MC est équivalente à~MU pour la méthode de Coombs: en effet, si les manipulateurs ont la capacité d'éliminer successivement les candidats~$d_1, \ldots, d_{C-1}$, alors ils peuvent également le faire en utilisant l'ordre de préférence $(c \plusque d_{C-1} \plusque \ldots \plusque d_1)$.




\section{Specific algorithms IRV and its variants}\label{sec:vti_implem}

%\begin{center}
%\includegraphics[width=\textwidth]{../../Photos_notes/IMG_0267}
%\end{center}
%
%\begin{center}
%\includegraphics[width=\textwidth]{../../Photos_notes/IMG_0269}
%\end{center}

VTI fut l'un des premiers systèmes de vote pour lesquels décider MI (et \emph{a fortiori} MC) fut prouvé \complexNP-complet~\citep{bartholdi1991stv}. De plus, il semble particulièrement résistant à la manipulation~\citep{chamberlin1984observed,bartholdi1991stv, lepelley1994vulnerability, lepelley2003homogeneity, green2011four, green2014strategic}. 
%
%Certaines études précédentes tendent à montrer que VTI possède des propriétés rares et intéressantes. D'une part, avec des profils de préférences tirées de populations réelles, il semble manipulable bien moins fréquemment que plusieurs autres modes de scrutin \citep{chamberlin1984observed}. D'autre part, il est \complexNP-complet de décider s'il peut être manipulé \citep{bartholdi1991stv}. 
%
À notre connaissance, l'algorithme de manipulation le plus rapide pour la manipulation individuelle est en $O(2^C V C^k))$ \citep{walsh2010empirical} et le plus rapide pour la manipulation par coalition est en $O(C!(V+Ck))$ \citep{coleman2007complexity}.

\medskip
Pour ces raisons, nous avons accordé une importance particulière aux méthodes pour VTI ainsi que pour deux de ses variantes, SE et CVTI, dont nous verrons dans les chapitres suivants qu'elles sont également assez résistantes à la manipulation. Pour CVTI, on sait, par les théorèmes de condorcification \ref{thm_Condorcifie_aussi_bon} et~\ref{thm:cond_strictement_meilleur} qu'il est strictement moins manipulable que VTI et il serait intéressant de mesurer quantitativement l'écart de manipulabilité. Pour SE, nous savons que c'est un système strictement plus manipulable que VTI (section~\ref{sec:reducation_general_vers_svbe}), mais il présente l'avantage d'être souvent plus simple que VTI et de permettre des algorithmes plus rapides. Par exemple, quand on veut prouver que VTI n'est pas manipulable, il est suffisant de montrer que SE ne l'est pas; et nous verrons que c'est généralement plus rapide.

%\subsection{IRV vs. Exhaustive Ballot}

%\subsection{Liens entre critère de Condorcet, MT et MU}
%
%Afin d'avoir une implantation efficace, il est important de bien cerner les propriétés des systèmes de vote SE et VTI. Tout d'abord, examinons le lien entre l'élection d'un vainqueur de Condorcet et les notions de MT et~MU.
%
%Notons $\winner$ le vainqueur sincère de SE et VTI. Si $\winner$ possède une défaite (absolue) contre un certain candidat~$c$, alors il est clair que VTI et SE sont MT et MU (donc MC) en faveur de~$c$: il suffit que tous les électeurs qui préfèrent $c$ à $\winner$ mettent~$c$ en tête de bulletin pour faire gagner~$c$, ce qui est possible en unisson et automatique en stratégie triviale. En particulier, si $\winner$ n'est pas vainqueur de Condorcet, alors il existe un candidat~$c$ qui peut bénéficier de MT et de MU.
%
%Cependant, il n'est pas nécessaire que $\winner$ possède une défaite pour subir une MT ou une MU. En effet, considérons le profil suivant. 
%\begin{center}
%\begin{tabular}{lcl}
%%Preferences: & \hspace{1cm} & Matrix of duels:\\
%$
%\begin{array}{c|c|c|c}
%	   5    &    6    &    2    &    4    \\ \hline
%	\winner &    a    &    a    &    c    \\
%	   c    & \winner &    c    & \winner \\
%	   a    &    c    & \winner &    a    \\
%\end{array}
%$ 
%& &
%\begin{tabular}{IcIc|c|cI}
%\Cline{1pt}{1-4}
%\multicolumn{1}{IcI}{$D(\omega)$} & $a$ & $c$ & $\winner$ \\ \Cline{1pt}{1-4}
%$a$                     		  &  -- & 8 & 8  \\ \hline
%$c$                     		  & 9 & --  & 6  \\ \hline
%$\winner$                         & 9 & 11 & --   \\ \Cline{1pt}{1-4}
%\end{tabular}
%\end{tabular}
%\end{center}
%On vérifie aisément que $\winner$ est vainqueur de VTI et SE. Il est également vainqueur de Condorcet. Mais $c$ bénéficie d'une MT et d'une MU: en effet, si tous les électeurs qui préfèrent $c$ à $\winner$ placent $c$ en tête, alors $\winner$ est éliminé au premier tour et c'est bien $c$ qui est vainqueur.
%
%Ainsi, il y a une implication de l'élection d'un candidat qui possède une défaite vers les notions de MT et MU, mais la réciproque n'est pas vraie.
%
%\subsection{Implications entre MT et MU pour VTI et SE}
%
%
%À présent, nous étudions les liens entre les notions de MT et MU elle-mêmes.
%
%
%\begin{prop}
%\label{thm:EB.STV.MU.TM}
%Soit $\winner \in \mathcal{C}$ le vainqueur sincère et $c \in \mathcal{C} \setminus {\winner}$. Les conditions suivantes sont équivalentes\footnote{On suppose que la même règle de départage est utilisée pour SE et VTI.}.
%\begin{enumerate}
%	\item \label{en:EB.TM} SE est MT en faveur de $c$.
%	\item \label{en:STV.TM} VTI est MT en faveur de $c$.
%	\item \label{en:STV.MU} VTI est MU en faveur de $c$.
%\end{enumerate}
%
%Quand elles sont vérifiées, la suivante l'est également.
%\begin{enumerate}
%	\setcounter{enumi}{3}
%	\item \label{en:EB.MU} SE est MU en faveur de $c$.
%\end{enumerate}
%
%La réciproque est fausse.
%\end{prop}
%
%\begin{proof}
%\ref{en:EB.TM} $\Leftrightarrow$ \ref{en:STV.TM}: c'est trivial.
%
%\ref{en:STV.TM} $\Rightarrow$ \ref{en:STV.MU}: Puisque la MT fonctionne, cela signifie que si les manipulateurs (ceux qui préfèrent $c$ à $\winner$) prétendent que $c$ est leur candidat préféré, alors $c$ n'est jamais éliminé: l'ordre des autres candidats sur leur bulletin n'a donc pas d'importance. Par conséquent, si tous les manipulateurs placent $c$ en tête de bulletin et les autres candidats dans un ordre arbitraire, alors $c$~est élu.
%
%\ref{en:STV.MU} $\Rightarrow$ \ref{en:STV.TM}: En VTI, si certains candidats n'ont aucune vote au premier tour, alors ils sont tous éliminés avant tout autre candidat. En effet, au premier tour, l'un d'entre eux est éliminé (le choix duquel dépend de la règle de départage), puis 0 vote est transféré, donc un second d'entre eux est éliminé, et ainsi de suite.
%
%Le candidat $c$ ne reçoit aucun vote de la part d'électeurs qui préfèrent $\winner$ à $c$. Donc en MU, les manipulateurs ont besoin de placer $c$ en tête de bulletin, sinon il serait éliminé dans l'un des premiers tours de dépouillement. Puisque la MU fonctionne, $c$ n'est jamais éliminé et l'ordre des candidats sur leurs bulletins n'a pas d'importance. Par conséquent, la MT fonctionne également.
%
%\ref{en:STV.MU} $\Rightarrow$ \ref{en:EB.MU}: c'est trivial.
%
%Montrons enfin que la réciproque \ref{en:EB.MU} $\Rightarrow$ \ref{en:EB.TM} n'est pas vraie (par exemple). Dans l'exemple de la table \ref{tab:EB.MU.not.TM}, le chemin d'élimination sincère est $(c, d_4, d_3, d_2, d_1)$ et $\winner$ est vainqueur. Dans les tentatives de MU ou MT en faveur de~$c$, le chemin d'élimination commence nécessairement par $(d_4, \winner, d_3)$. À ce moment-là, en MT, le candidat~$d_2$ est éliminé et $c$ perd finalement contre~$d_1$. Mais en MU, les manipulateurs peuvent voter pour $d_2$ et éliminer $d_1$: ainsi, $c$ gagne finalement contre~$d_2$. Ainsi $c$ peut bénéficier de MU mais pas de MT. En fait, il est même facile de vérifier que dans cet exemple, aucun candidat ne peut bénéficier de~MT.
%
%\begin{table}[htbp]
%	\centering
%$$
%\begin{array}{c|c|c|c|c|c}
%	   3    &    7    &    6    &    5    &    3    &    1    \\ \hline
%	\winner &   d_1   &   d_2   &   d_3   &   d_4   &    c    \\
%	   c    & \winner & \winner & \winner &    c    & \winner \\
%	  d_2   &    c    &   d_1   &    c    & \winner &   d_1   \\
%	  d_1   &   d_2   &    c    &   d_1   &   d_1   &   d_4   \\
%	  d_4   &   d_4   &   d_4   &   d_4   &   d_3   &   d_3   \\
%	  d_3   &   d_3   &   d_3   &   d_2   &   d_2   &   d_2   \\
%\end{array}
%$$
%	\caption{Exemple: SE est MU mais pas MT.}
%	\label{tab:EB.MU.not.TM}
%\end{table}
%\end{proof}
%
%\begin{table}[htbp]
%	\centering
%		\begin{tabular}{IcIc|cI}
%		\Cline{1pt}{1-3}
%$C$ & MT (sur 10\,000) & MU (sur 10\,000) \\ \Cline{1pt}{1-3}
%3 & 	1\,242 & 	1\,242 \\\hline
%4 & 	2\,289 & 	2\,289 \\\hline
%5 & 	3\,337 & 	3\,337 \\\hline
%6 & 	3\,994 & 	3\,994 \\\hline
%7 & 	4\,781 & 	4\,781 \\\hline
%8 & 	5\,469 & 	5\,469 \\\hline
%9 & 	5\,784 & 	5\,784 \\\hline
%10 & 	6\,180 & 	6\,180 \\\hline
%11 & 	6\,481 & 	6\,481 \\\hline
%12 & 	6\,855 & 	6\,855 \\\hline
%13 & 	6\,986 & 	6\,986 \\\hline
%14 & 	7\,318 & 	7\,318 \\\hline
%15 & 	7\,475 & 	7\,475 \\ \Cline{1pt}{1-3}
%		\end{tabular}
%	\caption{Comparaison de MU et MT pour SE en culture impartiale avec $V = 33$ électeurs.}
%	\label{tab:EB.MU.TM.comparison}
%\end{table}
%
%Toutefois, avoir une MU mais pas de MT pour SE est extrêmement rare: le table~\ref{tab:EB.MU.TM.comparison} montre le résultats de simulations pour $V = 33$ électeurs, un nombre variable de candidats $C$ et 10\,000 populations pour chaque valeur de~$C$. Sur toutes ces populations, nous n'avons tout simplement jamais observé le phénomène, et il en a été de même pour d'autres types de culture et d'autres valeurs des paramètres\footnote{Nous avons constaté cette rareté à notre grand dam! Initialement, nous espérions que \svvamp{} nous fournirait un contre-exemple. Constatant l'échec de la force brutale, nous avons dû nous résoudre à réfléchir un peu...}.
%
%La proposition~\ref{thm:EB.STV.MU.TM} est particulièrement intéressante puisqu'elle permet de décider MU pour VTI, simplement en décidant TM: ainsi, on peut utiliser un algorithme polynomial. Ceci améliore donc la technique de \cite{walsh2010empirical}, qui décide MU en utilisant un algorithme de complexité $C!$.


\subsection{CM algorithms for EB}

\begin{algorithm}
\caption{MC exact en faveur de $c$ pour SE}
\label{alg:EB.CM.exact}
\begin{algorithmic}[1]
\STATE $LiceIni = \ens{C}$
\STATE $LicesPossiblesIniTour = \{LiceIni\}$
\FOR{$t = 1 \to C-1$} 
	\STATE $LicesPossiblesFinTour = \varnothing$
	\FORALL{$LiceIni \in LicesPossiblesIniTour$}
		\FORALL{$d \in LiceIni \setminus \{c\}$}
			\STATE $test =$ sous l'hypothèse que le tour d'élimination $t$ se déroule entre les candidats de $LiceIni$, les manipulateurs peuvent-ils choisir leurs bulletins de façon à éliminer~$d$?
			\IF{$test$}
			  \STATE $LiceFin = LiceIni \setminus \{d\}$
			  \STATE $LicesPossiblesFinTour = LicesPossiblesFinTour \cup \{LiceFin\}$
			\ENDIF
		\ENDFOR
	\ENDFOR
	\STATE $LicesPossiblesIniTour = LicesPossiblesFinTour$
\ENDFOR
\RETURN ($LicesPossiblesFinTour \neq \{\})$
\end{algorithmic}
\end{algorithm}

En mode exact, \svvamp{} utilise l'algorithme~\ref{alg:EB.CM.exact}, qui est une adaptation pour~SE d'un algorithme initialement conçu pour VTI par \cite{coleman2007complexity}. À~chaque tour, on détermine l'ensemble des situations atteignables par les manipulateurs à la fin du tour, c'est-à-dire les candidats restant en lice (en ignorant les situations où $c$ est éliminé). Il est clair que cet algorithme termine et permet de décider la manipulabilité: à la fin du tour $C-1$, l'ensemble $LicesPossiblesFinTour$ est non vide si et seulement si une manipulation est possible en faveur de~$c$. Dans ce cas, l'ensemble $LicesPossiblesFinTour$ contient nécessairement uniquement le singleton $\{c\}$.

La principale différence avec l'algorithme de \cite{coleman2007complexity} est la suivante: dans VTI, le bulletin utilisé par un manipulateur au tour~$t$ en faveur d'un candidat~$d$ est bloqué jusqu'à ce que le candidat~$d$ soit éliminé. Pour cette raison, éliminer un certain candidat $d$ puis $e$ ou l'inverse n'est pas forcément équivalent pour les manipulateurs: même s'il reste les mêmes candidats au début du tour suivant, les manipulateurs bloqués ne sont pas forcément les mêmes. Pour cette raison, on peut être amené à explorer tous les ordres d'élimination possibles, ce qui cause une complexité en $C!$.

En revanche, en SE, la situation des manipulateurs au début d'un tour est entièrement caractérisée par les candidats restant en lice. Ainsi, l'algorithme~\ref{alg:EB.CM.exact} explore, au pire, tous les sous-ensembles de~$\ens{C}$ et possède donc une complexité en~$2^C$ <<\,seulement\,>>.

\begin{algorithm}
\caption{MC rapide en faveur de $c$ pour SE}
\label{alg:SE.MC.fast}
\begin{algorithmic}[1]
\STATE $Lice = \ens{C}$
\FOR{$t = 1 \to C-1$}
	\STATE $Eliminables = \{d \in Lice \setminus \{c\}$ t.q., sous l'hypothèse que le tour l'élimination $t$ se déroule entre les candidats de $Lice$, les manipulateurs peuvent choisir leurs bulletins de façon à éliminer $d\}$.
	\IF{$Eliminables = \varnothing$}
		\RETURN \textbf{Maybe}
	\ELSIF{$t = C-1$}
		\RETURN \TRUE
	\ENDIF
	\STATE $d_{\text{meilleur}} = \arg\max\{\text{Situation}(d), d \in Eliminables\}$
	\STATE $Lice = Lice \setminus \{d_{\text{meilleur}}\}$
\ENDFOR
\end{algorithmic}
\end{algorithm}

En mode rapide (obtenu avec \mylstinline"CM_option = fast"), \svvamp{} utilise l'algorithme~\ref{alg:SE.MC.fast}, qui est une contribution originale. À chaque début de tour, les manipulateurs examinent tous les candidats (différents de $c$) qu'ils sont capables d'éliminer. Parmi eux, ils choisissent le meilleur candidat $d_{\text{meilleur}}$, au sens d'une fonction bien choisie notée Situation, qui est chargée d'évaluer la situation après l'élimination chaque adversaire $d$ possible. Il s'agit donc d'un algorithme glouton.

Un choix important pour cet algorithme est donc celui de la fonction Situation. Dans \svvamp{}, on utilise la fonction suivante:
$$
\text{Situation}(d) = \score(c \mid \cancel{d}) - \max_{e \neq c}(\score(e \mid \cancel{d})),
$$
où $\score(e \mid \cancel{d})$ désigne le score attribué à un candidat~$e$, par les électeurs sincères uniquement, dans le cas où $d$ est éliminé, c'est-à-dire dans un tour se déroulant entre les membres de $Lice \setminus \{d\}$.

Il est clair que cet algorithme termine en temps polynomial et que s'il renvoie \textbf{True}, alors le profil est manipulable en faveur du candidat $c$. En revanche, s'il renvoie \textbf{Maybe}, il est impossible de conclure.

\medskip

\begin{figure}
\begin{center}
\includegraphics[width=\relativewidth\textwidth]{figures/eb_algos_manip.eps}
\end{center}
\caption{SE: taux de manipulabilité trouvé par les différents algorithmes. Culture impartiale, $V = 33$.}\label{fig:eb_algos_manip}
\end{figure}

La figure~\ref{fig:eb_algos_manip} montre les performances de \svvamp{} en mode rapide. On considère une culture impartiale, $V = 33$ électeurs et un nombre variable de candidats. Chaque point est tiré à partir de 10\,000 populations aléatoires. On trace le taux de MC trouvé par l'algorithme exact à titre de référence.

La borne supérieure du taux de MC fournie en mode rapide est donnée par les cas où les tests préliminaires ont permis de prouver que le profil est non manipulable, par exemple lorsque le vainqueur sincère est un favori majoritaire. On constate que, dans ce type de culture, pour $C \geq 4$, les tests préliminaires ne sont capables de prouver la non-manipulabilité que dans une proportion des cas extrêmement faible\footnote{Sur les expériences issues d'élections réelles du chapitre~\ref{sec:simulations_expe}, nous verrons, cependant, que pour de nombreux modes de scrutin, les tests préliminaires permettent de conclure dans une proportion des cas non négligeable, ce qui motive leur implantation.}.

En revanche, la borne inférieure du taux de MC fournie en mode rapide est très proche du taux exact. À titre de référence, on a aussi indiqué la manipulation triviale: en effet, un bon indice de performance est la proportion de manipulations qui ne sont pas trouvées par la MT mais le sont par l'algorithme rapide. Pour chaque valeur de $C$ de cette figure, l'algorithme trouve toujours au moins 96~\% des manipulations non trouvées par la MT (99~\% des manipulations).

En résumé, le mode rapide permet de prouver la manipulabilité dans une proportion élevée des cas où c'est possible, grâce à l'algorithme rapide~\ref{alg:SE.MC.fast}, mais permet rarement de prouver la non-manipulabilité.

\medskip

\begin{figure}
\begin{center}
\includegraphics[width=\relativewidth\textwidth]{figures/eb_algos_time.eps}
\end{center}
\caption{SE: temps de calcul des différents algorithmes. Culture impartiale, $V = 33$.}\label{fig:eb_algos_time}
\end{figure}

La figure~\ref{fig:eb_algos_time} permet de visualiser le gain de temps obtenu grâce à l'algorithme rapide. En pratique, la complexité moyenne observée sur ces courbes est $1,\!6 \times C \text{ ms/population}$ pour le mode rapide, et $0,\!5 \times 1,\!75^C \text{ ms/population}$ pour le mode exact de \svvamp{}\footnote{La machine utilisée est un Dell Precision M6600, Intel Core I7-2820QM à 2,30 GHz, 8 Mo de cache, 16 Go de RAM à 1,33 GHz en DDR3.}. On notera que, pour l'algorithme exact, la complexité n'est pas en $2^C$, ce qui s'explique par plusieurs raisons: premièrement, le comportement théorique en $2^C$ exprime une complexité en pire cas, alors qu'on mesure la complexité moyenne. Deuxièmement, il n'y a pas le même taux de manipulabilité en fonction de~$C$; or, les configurations manipulables sont, d'habitude, plus rapides à traiter, notamment parce que l'algorithme rapide peut souvent conclure avant même qu'on fasse appel à l'algorithme exact. Troisièmement, \svvamp{} possède quelques optimisations supplémentaires, en particulier les tests préliminaires qui lui permettent de conclure rapidement dans un certain nombre de cas.

Ainsi, notre algorithme approché~\ref{alg:SE.MC.fast} pour la MC de SE est efficace pour prouver la manipulabilité et bien plus rapide que l'algorithme exact. Sa principale limite est qu'il est incapable de prouver la non-manipulabilité le cas échéant. En pratique, dans le mode rapide de \svvamp{}, l'algorithme~\ref{alg:SE.MC.fast} est complété par des tests préliminaires qui peuvent prouver la non-manipulabilité mais dont le taux de réussite peut être très faible dans certaines cultures. Pour des travaux futurs, il serait particulièrement intéressant d'avoir un algorithme en temps polynomial qui soit capable de prouver la non-manipulabilité avec un bon taux de succès, en complément de notre algorithme qui est relativement efficace pour traiter les cas de manipulabilité.

\subsection{CM algorithms for IRV}\label{sec:algos_vti}

Pour VTI, comme nous l'évoquions, le problème est plus complexe que pour~SE: comme les manipulateurs sont immobilisés par leurs votes passés en faveur de candidats non encore éliminés, il est nécessaire de prendre en compte l'historique des tours précédents.

En mode exact, \svvamp{} utilise l'algorithme de \cite{coleman2007complexity}, dont la complexité est en $C!$.

En mode rapide, on utilise une approche gloutonne similaire à l'algorithme~\ref{alg:SE.MC.fast}: à~chaque tour, parmi les candidats qu'on peut éliminer, on choisit celui qui maximise une fonction évaluant la situation obtenue. En l'occurrence, nous avons choisie la même fonction que pour SE.

\medskip
Le calcul de MC pour VTI est donc basé sur deux algorithmes, rapide et exact. Mais en pratique, dans \svvamp{}, la MC de VTI possède trois options.
\begin{description}
\item \mylstinline"fast": Après les tests préliminaires, seul l'algorithme rapide est utilisé.
\item \mylstinline"slow": En outre, on détermine si SE est manipulable en utilisant l'algorithme exact de SE. Si c'est faux, on conclut que VTI n'est pas manipulable. Si c'est vrai, on profite de l'occasion pour tester le chemin d'élimination permettant la manipulation en SE, au cas où il permettrait de manipuler également~VTI.
\item \mylstinline"exact": Si les procédés ci-dessus ne permettent pas de conclure, alors on utilise l'algorithme exact de~VTI.
\end{description}

L'option \mylstinline"slow" offre donc une possibilité intermédiaire, plus rapide que l'option exacte, mais plus performante que l'option rapide, en particulier pour décider les cas de non-manipulabilité.

\medskip

\begin{figure}
\begin{center}
\includegraphics[width=\relativewidth\textwidth]{figures/irv_algos_manip.eps}
\end{center}
\caption{VTI: taux de manipulabilité trouvé par les différents algorithmes. Culture impartiale, $V = 33$.}\label{fig:irv_algos_manip}
\end{figure}

La figure~\ref{fig:irv_algos_manip} présente les performances des différentes options pour VTI, dans les mêmes conditions que la figure~\ref{fig:eb_algos_manip} pour SE. Pour chaque valeur de $C$ de cette figure, le mode rapide trouve toujours au moins 88~\% des manipulations non trouvées par la MT (97~\% des manipulations). En revanche, comme pour SE, la borne supérieure trouvée en mode rapide est généralement proche de~1: le mode rapide n'est pas très bien adapté pour prouver la non-manipulabilité.

En mode lent, on améliore la borne inférieure trouvée: pour chaque valeur de~$C$ de cette figure, le mode lent trouve toujours au moins 95~\% des manipulations non trouvées par la MT (99~\% des manipulations). Mais surtout, la borne supérieure fournie par le mode lent est très proche de la courbe de MC exacte, ce qui signifie qu'on est capable de prouver de nombreux cas de non-manipulabilité. En l'occurrence, pour chaque valeur de $C$, le mode lent trouve toujours au moins 99~\% des cas de non-manipulabilité. Ainsi, l'écart entre les bornes inférieure et supérieure trouvées en mode lent est au maximum d'environ 1~\%, ce qui signifie que la valeur conventionnelle \mylstinline"nan" n'a été renvoyée que dans environ 1~\% des cas en mode lent.

\medskip

\begin{figure}
\begin{center}
\includegraphics[width=\relativewidth\textwidth]{figures/irv_algos_time.eps}
\end{center}
\caption{VTI: temps de calcul des différents algorithmes. Culture impartiale, $V = 33$.}\label{fig:irv_algos_time}
\end{figure}

Enfin, la figure~\ref{fig:irv_algos_time} présente les temps de calculs pour les différents algorithmes dans le cas de VTI. En pratique, la complexité moyenne constatée sur cette figure est $2,\!0 \times C \text{ ms/population}$ pour le mode rapide, $0,\!5 \times 1,\!75^C \text{ ms/population}$ pour le mode lent et $4,\!1 \times (0,\!23 C)^{0,\!57 C} \text{ ms/population}$ pour le mode exact\footnote{Le comportement théorique en pire cas est de l'ordre de $C!$, c'est-à-dire de l'ordre de $C^C$ en utilisant la formule de Stirling. En ajustant les paramètres, on obtient le comportement approximatif énoncé.}. Pour le mode lent, il s'agit du même comportement asymptotique que pour le mode exact de SE, ce qui est naturel vu notre façon de procéder: en effet, les calculs supplémentaires à effectuer pour l'adaptation à VTI sont négligeables devant ceux nécessaires pour l'algorithme exact de SE (qui demandent un temps exponentiel en~$C$).


\subsection{CM algorithms for CIRV}\label{sec:algos_cvti}

Pour CVTI, nous utilisons une heuristique que nous allons décrire brièvement.

Tout d'abord, pour chaque candidat $c \neq \winner$, on détermine si VTI est manipulable  en utilisant l'une des options disponibles (rapide, lente ou exacte). Ensuite, en utilisant le chemin d'élimination obtenu, on essaie de mettre au point les bulletins des manipulateurs tout en empêchant qu'il y ait un vainqueur de Condorcet distinct de~$c$. Si le profil initial est Condorcet, on sait d'ailleurs qu'il ne doit pas y avoir de vainqueur de Condorcet du tout (lemme~\ref{thm:cond_non_manip_vers_cond}).

%Pour cela, on commence par remarquer que pour obtenir le chemin d'élimination désiré, il est obligatoire que certains électeurs placent certains candidats en tête de leur bulletin (pour éviter leur élimination). Pour les manipulateurs qui n'ont pas encore placé~$c$ dans leur bulletin, on peut également ajouter~$c$ à la plus haute place disponible, sans altérer la réussite de la manipulation au sens de VTI. Ces constatations donnent automatiquement des voix supplémentaires aux candidats concernés dans la matrice des duels, qui s'ajoutent aux voix des électeurs sincères.
%
%Il est alors possible que certains candidats aient déjà des défaites dans la matrice des duels. On peut donc les mettre aussi haut qu'on le souhaite dans les emplacements libres des bulletins des manipulateurs. Ceci fournit des voix supplémentaires à ces candidats dans la matrice des duels, et il est ainsi possible que des candidats qui ne possédaient pas encore de défaite en possèdent à présent. On peut donc itérer le processus.
%
%Empiriquement, on constate généralement qu'à ce stade, tous les candidats distincts de~$c$ possèdent une défaite (donc la manipulation réussit). Si ce n'est pas le cas, on complète les bulletins des manipulateurs en attribuant aux candidats restants un ordre arbitraire et en les plaçant dans les places libres des bulletins, tout en leur faisant subir à chaque fois une permutation circulaire: le but de cette heuristique est de créer un paradoxe de Condorcet entre ces candidats.

Pour cela, on place, tout d'abord, le candidat~$c$ aussi haut que possible dans les bulletins, puis les candidats dont on sait déjà qu'ils possèdent une défaite dans la matrice des duels. Ce faisant, il est possible que d'autres candidats acquièrent des défaites et on peut itérer le processus. Pour plus de détails, on pourra se reporter au code de la classe correspondante dans \svvamp{}.

Si le processus réussit, c'est-à-dire s'il n'y a pas de vainqueur de Condorcet distinct de~$c$ à la fin de l'algorithme, alors MC est prouvée. Dans le cas contraire, on reste dans l'incertitude: en effet, on n'a testé qu'un chemin d'élimination parmi ceux qui permettent de manipuler VTI, et le processus employé pour empêcher l'apparition d'un vainqueur de Condorcet a fait l'objet de choix arbitraires. Ainsi, cet algorithme ne fournit qu'une borne inférieure de la manipulabilité.

Cependant, on dispose également d'une borne supérieure: si VTI n'est pas manipulable, alors CVTI ne l'est pas non plus, par le théorème faible de condorcification~\ref{thm_Condorcifie_aussi_bon}. Dans les chapitres suivants, nous verrons qu'en pratique, l'écart entre la borne inférieure et la borne supérieure est en général très faible, ce qui assure, d'une part, que l'heuristique utilisée pour CVTI est relativement efficace, et montrera, d'autre part, que l'écart de manipulabilité entre VTI et CVTI, quoique non nul par le théorème fort de condorcification~\ref{thm:cond_strictement_meilleur}, est en fait assez faible.




%\subsection{Performance of IRV algorithms (à inclure dans les subsections précédentes puis supprimer)}
%
%In \svvamp, the implementation of MC for IRV is closely linked to Exhaustive Ballot (a voting system similar to IRV but with actual rounds) and Condorcet-IRV (one of the Condorcet variants of IRV). In addition to an \mylstinline$'exact'$ algorithm, which uses non-polynomial algorithms adapted from~\cite{walsh2009stv}, we propose two original heuristics accessed through \mylstinline$'fast'$ and \mylstinline$'slow'$ options.
%
%
%\begin{figure}
%	\begin{bigcenter}
%		\includegraphics[width=0.53\textwidth]{figures/IRVprecision.eps}
%	\end{bigcenter}
%	\vspace{-.5cm}
%	\caption{Precision of algorithms for IRV. Spheroid model (Impartial Culture), $V = 33$.}
%	\label{fig:irvprecision}
%	\vspace{-.5cm}
%\end{figure}
%
%\begin{figure}
%	\begin{bigcenter}
%		\includegraphics[width=0.53\textwidth]{figures/IRVtime.eps}
%	\end{bigcenter}
%	\vspace{-.5cm}
%	\caption{Computation time of algorithms for IRV. Spheroid model (Impartial Culture), $V = 33$.}
%	\label{fig:irvtime}
%	\vspace{-.5cm}
%\end{figure}
%
%
%Describing how \mylstinline$'fast'$ and \mylstinline$'slow'$ are implemented under the hood is out of the scope of this article, but their main features are that: \mylstinline$'fast'$ is a polynomial algorithm designed to be efficient at finding manipulation if they exist; \mylstinline$'slow'$ is a non-polynomial algorithm that aims at deciding MC in most cases while running significantly faster than the exact algorithm derived from \cite{walsh2009stv}.
%
%This is illustrated by Figures \ref{fig:irvprecision} and \ref{fig:irvtime}, which study how the number of candidates impact the performance. For each figure, the results are obtained by averaging 10,000 random instances. Figure \ref{fig:irvprecision} indicates the accuracy of non-exact algorithms by giving their lower bound for manipulability (the algorithms decided MC) and their upper bound (the algorithm decided MC or stopped before decision). For parameters where the \mylstinline$'exact'$ algorithm can run, we see that the \mylstinline$'fast'$ option manages to detect most of the manipulable elections (Fast MC, lower bound). To compare with, simply running the trivial manipulation (TM) fails to detect a significant part of these. The main drawback of the \mylstinline$'fast'$ option is that it has great difficulty in proving the absence of manipulation (Fast MC, upper bound): even if empirically most of the cases where it does not decide corresponds to non-manipulable elections, no guarantee is provided. This justified the introduction of the \mylstinline$'slow'$ option, which decides MC with high accuracy (Slow MC bounds in the Figure) at the price of an increased time complexity.
%
%The computation time of the algorithms is given by Figure~\ref{fig:irvtime}. It has been measured on a regular personal laptop used for benchmarking. We see that \mylstinline$'fast'$ has a running time greater than TM but stays very efficient with less than 50ms for all the considered parameters. On the other hand, the non-polynomial property of \mylstinline$'slow'$ and \mylstinline$'exact'$ is clearly confirmed, but we can observe that \mylstinline$'slow'$ is significantly faster than \mylstinline$'exact'$, allowing us to explore a larger set of parameters for the same time budget.




%\subsection{IRV Family}
%
%For EB, in fast mode, we use an original heuristic (out of the scope of this paper). In exact mode, we use an algorithm adapted from~\cite{walsh2009stv}; its time complexity is of order $2^C$.
%
%For IRV, there are three options: \mylstinline$'fast'$, \mylstinline$'slow'$ and \mylstinline$'exact'$.
%\begin{itemize}
%\item In fast mode, we use an original heuristic. It can prove CM, but is unable to decide non CM (except when the preliminary checks are conclusive).
%\item In slow mode, we exploit EB. Indeed, when CM is impossible for EB, then it is impossible for IRV. This algorithm is quite efficient to prove CM or $\neg$CM. Its time complexity is of order $2^C$.
%\item In exact mode, we use an algorithm adapted from~\cite{walsh2009stv}.
%\end{itemize}
%
%For Condorcet-IRV, there is a fourth option: \mylstinline$'almost_exact'$.
%\begin{itemize}
%\item In fast mode, we rely on IRV's fast algorithm. Polynomial, can prove CM but unable to prove $\neg$CM.
%\item In slow mode, we rely on IRV's slow algorithm. Time complexity $2^C$, quite efficient to prove CM or $\neg$CM.
%\item In almost exact mode, we rely on IRV's exact algorithm, of time complexity $C!$. We use an original heuristic to prevent an undesired candidate from becoming a Condorcet winner. In practice, this is extremely efficient to prove CM or $\neg$CM.
%\item In exact mode, we simply use the generic algorithm for superclass Election.
%\end{itemize}
%
%Each of these algorithms builds on the previous one, as already mentioned in section~\ref{sec:bounds}. For example, in slow mode, \svvamp starts by trying the fast algorithm. Only if this first attempt in inconclusive does it use the slow algorithm.




%\section{Conclusion}
%
%Nous avons présenté \svvamp{}, un simulateur flexible dédié à l'étude des modes de scrutin et de leur manipulation, sous diverses hypothèses sur les préférences des électeurs. Les populations d'électeurs peuvent être importées depuis des fichiers externes ou générées avec divers modèles aléatoires. Elles peuvent être testées sur des élections utilisant plus de 20~modes de scrutin, avec une variété de critères de manipulation.
%
%Alors que des algorithmes correspondant à l'état de l'art sont implantés pour une bonne partie de ces systèmes de vote, les méthodes génériques définies dans \svvamp{} permettent aux développeurs de définir rapidement un nouveau système de vote, simplement par sa règle de détermination du vainqueur, et de bénéficier immédiatement d'algorithmes de manipulation génériques, ce qui rend \svvamp{} facilement extensible.
%%
%%We hope that this simulator will be useful for the social choice community, to perform various analysis on paradoxes related to voting systems.
%Nous espérons qu'il sera utile pour les chercheurs, les enseignants, les étudiants et toutes les autres personnes intéressées par la théorie du vote.
%%We hope that it will be useful to researchers, teachers and students interested in voting theory. 
